{
    "version": "https://jsonfeed.org/version/1",
    "title": "tim-munuhe",
    "home_page_url": "tim-munuhe.github.io/",
    "feed_url": "tim-munuhe.github.io/feed.json",
    "description": null,
    "icon": "tim-munuhe.github.io/apple-touch-icon.png",
    "favicon": "tim-munuhe.github.io/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "Timothy W. Munuhe, Ph.D.",
        "url": "tim-munuhe.gitub.io",
        "avatar": null
    },
    
"items": [
    
        {
            "id": "tim-munuhe.github.io/2021/06/07/solve-1d-darcy-continuity",
            "title": "Basic Python with Darcy's Law - Solving Darcy's Law and Continuity Equation on 1D Mesh",
            "summary": "Create methods to solve for the pressure and velocity in a 1D saturated porous medium using Darcy's Law and the continuity equation",
            "content_text": "While the code we've developed so far allows us to go from parameters to plots in a few lines (assuming that all the classes and their methods are coded), the code also makes the assumption that the pressure is linear, which may not be true. To add more functionality to the code, let's figure out how to solve for the pressure distribution and velocity given only the parameters of the porous medium and the inlet and outlet conditions.MathIf the pressure is also unknown, then we need another equation to solve for pressure. So far, we've only used Darcy's Law. However, the assumptions of Darcy's law (slow flow through a porous medium) allow us to use another equation that accounts for mass conservation: the incompressible continuity equation:Since our case is 1D, we can simplify this to:This means that the velocity in the pipe is constant in the x-direction, which we knew before. What we want to find is the pressure distribution so we need to plug in Darcy's law into the simplified equation above:Our method from last week does not assume that the porous medium/liquid properties are constant so we'll keep the permeability and viscosity inside the parentheses. However, we can guess what the pressure distribution would be if we did. For now, let's move on to the equations that will be solved in Python.In the previous post, the velocity at the faces between the pressure points was coded but only briefly discussed. Let's flesh out the idea a bit more fully:The mesh consists of individual cells that meet at their left and right faces, as in the figure below:The middle cell experiences flow inwards from the left and outwards to the right. The adjacent cells have their own properties (K and mu specifically) so the pressure gradients within the cells may be different even though they have the same flow velocity (Darcy's Law). However, you also know that the pressure at the face is equal for both cell, so at face i+0.5:We don't know the pressure at the face so we need to remove it so that we have an equivalent permeability/viscosity factor that accounts for both cells. Luckily, we know K and mu in both cells so we can do some algebra to get the velocity across the face in terms of the adjacent cell pressures:This expression will take care of all interior faces.I wrote at the beginning that the continuity equation would allow use to solve for the pressure distribution, then combined it with Darcy's law. How does that work with our conception so far? Well, conservation of mass in a 1D mesh, assuming a constant cross-sectional area (i.e. all the faces have the same area), dictates that the velocity at both faces of cell i be equal to each other:We can combine this with the preceding equation to get our pressure relations. Since the cell of interest is cell i, we need Pi on one side and all the other terms on the other side:At the boundaries, the pressures are given so the boundary cells have slightly different terms: the inner faces are interior faces so their factors don't change. For the outer (boundary) faces, the pressure at the face is known so the velocity calculation is easy there. For the most left cell (at origin), Pi is calculated as:Basic Solution using Gauss-SeidelWe have equations for the pressure of each cell in terms of each other, thereby creating a system of algebraic equations. If we had 3 or 4, we could solve them by hand by plugging in pressures we know for equations we don't. But that gets less efficient the finer the mesh becomes. That being said, the system of equations we have now allows us to debug in a straightforward manner by checking each individual calculation. Let's use that to our advantage now and use some more sophisticated methods later.The most straightforward method I can think of to solve a system of algebraic equations is the Gauss-Seidel method. Skipping to the end, you substitute values of variables you do know forward into equations you do not. So, in our case, we know the inlet pressure (P0) so we can use that to find the pressure at the adjacent cell center P1. Notice though, that the pressure at that cell is also a function of the pressure at the next cell P2 that we do not know. So, we have a to make an initial guess then calculate this once or even multiple times. More reading is available at Gauss-Seidel’s wiki but some important points are:  Gauss-Seidel is an iterative method requiring repeated solution of the same equations with changing variables  Solutions (should1) improve with successive iterations until error is below some tolerance (convergence)  The number of iterations it takes to convergence depends on the quality of the initial guessSo we've prepped the math, let's jump to the code. First, the pseudocode:# Solver Parameterstol = 1E-6 # tolerance to determining stopping point of schemeres = 1.0 # residual (initially greater than the tolerancemax_iter = 1000 # max iterations (so it doesn't go forever)k = 0 # iteration counter## Initializep[2:N-1] = zeros(N-2,1) # initial guess for cell centers## Iteration Loopdo while ((res&gt;tol)&amp;&amp;(k&lt;max_iter))  p_prev = p # previous iteration  for i in range(1,N-1)    Aw = ... # \"west\" factor (i-1)\tAe = ... # \"east\" factor (i+1)\tAp = Aw + Ae # center factor (i)    p[i] = (Aw*p[i-1] + Ae*p[i+1])/Ap  end  res = sum(abs(p-p_prev)) # L2 norm of p_diff  k += 1 # increase iteration countend doWe first define the solver parameters: tol and max_iter define how soon the iteration loop terminates, depending either on convergence (tol) or a maximum iteration count. res and k represents how the scheme is doing and whichever reaches its limit sooner terminates the loop. Then, we initialize the middle mesh points’ solution. Since we have pressure boundaries, p[0] and p[N-1] are already solved. Since we do not know how many iterations it will take to get a converged pressure, we use a while loop as the outer loop with the residual as the main escape condition. The iteration count is insurance so the program doesn’t hang here.Inside the loop, the Gauss-Seidel method allows the use of the next iteration’s solution (p[i+1], p[i-1]) so the equations are are continually changing based on new data. There is another simple iterative method called the Jacobi method where the previous iteration’s solution (p_prev in the pseudocode) is used to calculate the next iteration. The difference then becomes convergence speed, where Gauss-Seidel is generally faster.So what does this look like in Python? Not too different from the pseudocode but it is adjusted for better debugging:def gauss_seidel(self,msh,pm): # need the mesh info and porous medium permeability        # Solver Parameters        tol = 1E-6 # tolerance to determining stopping point of scheme        res = np.array([1.0],dtype=float) # residual (initially greater than the tolerance        max_iter = 100 # max iterations (so it doesn't go forever)        k = 0 # iteration counter        # self.p[2:N-1] = zeros(N-2,1) # initial guess for cell centers        p_samp = np.zeros([1,4],dtype=float)        p_samp[0][:] = np.copy([self.p[1],self.p[3],self.p[msh.Nx-4],self.p[msh.Nx-2]])        # p_samp[0][0] = np.copy(self.p[1])        # p_samp[0][1] = np.copy(self.p[3])        # p_samp[0][2] = np.copy(self.p[msh.Nx-4])        # p_samp[0][3] = np.copy(self.p[msh.Nx-2])                ## Iteration Loop        while ((res[k]&gt;tol)and(k&lt;max_iter)):            p_prev = np.copy(self.p)# previous iteration (copy to avoid using same mem loc)            i = 1 # first cell center            fw = -pm.K[i]/self.mu[i]/(msh.x[i]-msh.xc[i]) # f_i-1/2 -&gt; f_i            fe = -pm.K[i]/self.mu[i]/(msh.xc[i+1]-msh.x[i]) # f_i -&gt; f_i+1/2            fee = -pm.K[i+1]/self.mu[i+1]/(msh.x[i+1]-msh.xc[i+1]) #f_i+1/2 -&gt; f_i+1            Aw = fw            Ae = fe*fee/(fe+fee)            self.p[i] = (Aw*self.p[i-1] + Ae*self.p[i+1])/(Aw + Ae)            for i in range(2,msh.Nx-2):                fww = -pm.K[i-1]/self.mu[i-1]/(msh.xc[i]-msh.x[i-1]) # f_i-1-&gt;i-1/2                fw = -pm.K[i]/self.mu[i]/(msh.x[i]-msh.xc[i]) # f_i-1/2 -&gt; f_i                fe = -pm.K[i]/self.mu[i]/(msh.xc[i+1]-msh.x[i]) # f_i -&gt; f_i+1/2                fee = -pm.K[i+1]/self.mu[i+1]/(msh.x[i+1]-msh.xc[i+1]) # f_i+1/2 -&gt; f_i+1                Aw = fw*fww/(fw+fww) # \"west\" factor (i-1 -&gt; i)                Ae = fe*fee/(fe+fee) # \"east\" factor (i -&gt; i+1)                self.p[i] = (Aw*self.p[i-1] + Ae*self.p[i+1])/(Aw + Ae)            i = msh.Nx-2 # last cell center            fww = -pm.K[i-1]/self.mu[i-1]/(msh.xc[i]-msh.x[i-1]) # f_i-1-&gt;i-1/2            fw = -pm.K[i]/self.mu[i]/(msh.x[i]-msh.xc[i]) # f_i-1/2 -&gt; f_i            fe = -pm.K[i]/self.mu[i]/(msh.xc[i+1]-msh.x[i]) # f_i -&gt; f_i+1/2            Aw = fw*fww/(fw+fww)             Ae = fe             self.p[i] = (Aw*self.p[i-1] + Ae*self.p[i+1])/(Aw + Ae)            p_samp = np.append(p_samp,[[self.p[1],self.p[3],self.p[msh.Nx-4],self.p[msh.Nx-2]]],axis=0)            res = np.append(res,[sum(abs(self.p-p_prev))]) # L2 norm of p_diff            k += 1 # increase iteration count            # print(k,res[k-1])                    # Iterations are complete. Now for output        print('Gauss-Seidel Complete. Iteration, Residual:',k,res[k])                # I suggest using the pandas library for output to file. Compare the code below to the output        # function coded from scratch in the mesh class        res_vec = res[:,np.newaxis]        df = pd.DataFrame(np.append(res_vec,p_samp,axis=1),columns=['res','x1','x3','x_N-4','x_N-2'])        df.to_csv('GS_Out.csv',sep='\\t')               return [k,res[k]]The solver parameters remain the same but I've added a pressure sampling array so that I can look at some exact numbers at different iterations. The coefficients Ae and Aw have also been constructed from factors representing what happens in halves of cells: fww represents the right half of the left cell, fw represents the left half of the center cell, and so on. The outermost cells have their pressures calculated outside of the loop, acknowledging that their outer faces are actually boundaries.  After the iteration loop, I report some data to the terminal (through print) and to a csv file through a pandas function. I hope you notice the much shorter code for outputting to a file with pandas compared to the scratch function in the mesh class. My recommendation: if you can't help fighting with your code, find tools that help you avoid those debugging battles.Since we're object-oriented, we can call this method quite easily using:## Pressure calculation using Gauss-Seidelfl_gs = fluid(base_mesh,base.fl)print('Original P:',fl_gs.p[0:4],      fl_gs.p[base_mesh.Nx-5:base_mesh.Nx-1])&gt;&gt;&gt; Original P: [0. 0. 0. 0.] [0. 0. 0. 0.][itera, res] = fl_gs.gauss_seidel(base_mesh,pm1)print('Gauss-Seidel P:',fl_gs.p[0:4],      fl_gs.p[base_mesh.Nx-5:base_mesh.Nx-1])&gt;&gt;&gt; Gauss-Seidel Complete. Iteration, Residual: 100 5.65338582708514&gt;&gt;&gt; Gauss-Seidel P: [ 0.         -0.00138227 -0.00462155 -0.00872932] [-80.27557742 -85.87430752 -91.51599336 -97.17199779]Remembering our desired solution, it seems the scheme is way off. What's  going on? Remember, Gauss-Seidel is an iterative method, meaning it gets closer and closer to its solution with each iteration. We can run it 2 more times and compare the pressures to see this process:[itera, res] = fl_gs.gauss_seidel(base_mesh,pm1)print('Gauss-Seidel P:',fl_gs.p[0:4],      fl_gs.p[base_mesh.Nx-5:base_mesh.Nx-1])fl_gs2 = copy.deepcopy(fl_gs) # another 100 iterations[itera, res] = fl_gs2.gauss_seidel(base_mesh,pm1)fl_gs3 = copy.deepcopy(fl_gs2) # another 100 iterations[itera, res] = fl_gs3.gauss_seidel(base_mesh,pm1)&gt;&gt;&gt; Plotting Code Here. Refer to Gauss_Seidel_Solve.py in Github Repo &lt;&lt;&lt;The initial condition is the zero condition, which is good for the inlet but  far from the outlet solution. Since the solutions of individual nodes are determined by the neighbor, getting the final solution using this iterative method requires “communication” between the nodes, and it takes a while for this to occur.So, at the very least, it is moving towards the correct solution, iteration by iteration. But this isn't an efficient way of solving it. Giving a better initial condition would definitely help and using better solution algorithms/methods can help. The successive over-relaxation (SOR) method takes a small step from the Gauss-Seidel method but, with some matrix set-up, I recommend using a direct solver.In any case, our code/method works. It took some work to get here so let's try a problem that we don't know the answer to. Assume the viscosity changes linearly according to:where g and b are constants. In truth, we can do some calculus and differential equation work to get the solution but, at first glance, it's not apparent what the solution should be. Even if you don't want to do the math, you can check the pressure solution by simply calculating the velocities at the faces to ensure they are constant.class fluid():...    def mu_lin(self,mesh):        N = mesh.Nx        L = mesh.x[N-1]        L0 = mesh.x[0]        for i in range(1,N):            self.mu[i] = (0.005-0.001)/(L-L0)*mesh.x[i]+0.001...fl_gs_mulin = fluid(base_mesh,base.fl)print('Original P:',fl_gs_mulin.p[0:4],      fl_gs_mulin.p[base_mesh.Nx-5:base_mesh.Nx-1])fl_gs_mulin.p_lin(base_mesh)print('Linear P:',fl_gs_mulin.p[0:4],      fl_gs_mulin.p[base_mesh.Nx-5:base_mesh.Nx-1])fl_gs_mulin.mu_lin(base_mesh)for k in range(0,51): [itera, res] = fl_gs_mulin.gauss_seidel(base_mesh,pm1)print('Final P:',fl_gs_mulin.p[0:4],      fl_gs_mulin.mu[base_mesh.Nx-5:base_mesh.Nx-1])&gt;&gt;&gt; Original P: [0. 0. 0. 0.] [0. 0. 0. 0.]&gt;&gt;&gt; Linear P: [ 0. -1. -3. -5.] [-93. -95. -97. -99.]...&gt;&gt;&gt; Gauss-Seidel Complete. Iteration, Residual: 1 9.391120880941628e-08&gt;&gt;&gt; Final P: [ 0.         -0.33986983 -1.05987099 -1.83320556] [0.00472 0.0048  0.00488 0.00496].&gt;&gt;&gt; Code to Plot mu, p, and u, also in the Gauss_Seidel_Solve.py file in Github Repo &lt;&lt;&lt;The pressure distribution is different now, but of course, the changing viscosity means that the pressure distribution must be higher in some places to maintain the same velocity throughout (remember, continuity equation/conservation of mass). This is reflected in the constant velocity profile shown below:In the next blog post, we'll use more efficient extant tools to solve this problem.Footnotes            To solve a linear system using the Gauss-Seidel method (or any of the methods I'll be discussing), the coefficient matrix needs to be diagonally dominant or symmetric positive definite. Otherwise, the code will not converge to a solution. This is a bit technical so just know, for the systems of equations I set up (where solutions at indivdual points are only calculated based on their neighbors), the matrices are always diagonally dominant. I urge caution before trying to use this on a linear system with random values or some “easy” linear system coming from a textbook. &#8617;      ",
            "content_html": "<p>While the code we've developed so far allows us to go from parameters to plots in a few lines (assuming that all the classes and their methods are coded), the code also makes the assumption that the pressure is linear, which may not be true. To add more functionality to the code, let's figure out how to solve for the pressure distribution and velocity given only the parameters of the porous medium and the inlet and outlet conditions.</p><h3 id=\"math\">Math</h3><p>If the pressure is also unknown, then we need another equation to solve for pressure. So far, we've only used Darcy's Law. However, the assumptions of Darcy's law (slow flow through a porous medium) allow us to use another equation that accounts for mass conservation: the incompressible continuity equation:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?\\nabla\\cdot\\vec{u}&space;=&space;0\" /></p><p>Since our case is 1D, we can simplify this to:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?\\dfrac{\\partial u}{\\partial x}&space;=&space;0\" /></p><p>This means that the velocity in the pipe is constant in the x-direction, which we knew before. What we want to find is the pressure distribution so we need to plug in Darcy's law into the simplified equation above:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?\\dfrac{\\partial u}{\\partial x}&space;=&space;\\dfrac{\\partial}{\\partial x}(-\\dfrac{K}{\\mu}\\dfrac{dP}{dx})&space;=&space;0\" /></p><p>Our method from last week does not assume that the porous medium/liquid properties are constant so we'll keep the permeability and viscosity inside the parentheses. However, we can guess what the pressure distribution would be if we did. For now, let's move on to the equations that will be solved in Python.</p><p>In the previous <a href=\"https://tim-munuhe.github.io/2021/05/14/mesh-fluidpm-plot\">post</a>, the velocity at the faces between the pressure points was coded but only briefly discussed. Let's flesh out the idea a bit more fully:</p><p>The mesh consists of individual cells that meet at their left and right faces, as in the figure below:</p><p><img src=\"../../../assets/images/Mid_mesh.png\" alt=\"Mid-mesh figure\" title=\"Cells and faces in middle of mesh\" /></p><p>The middle cell experiences flow inwards from the left and outwards to the right. The adjacent cells have their own properties (K and mu specifically) so the pressure gradients within the cells may be different even though they have the same flow velocity (Darcy's Law). However, you also know that the pressure at the face is equal for both cell, so at face <em>i+0.5</em>:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?u_{i+0.5}&space;=&space;\\dfrac{-K_i}{\\mu_i}\\dfrac{P_{i+0.5}-P_i}{\\triangle x/2}&space;=&space;\\dfrac{-K_{i+1}}{\\mu_{i+1}}\\dfrac{P_{i+1}-P_{i+0.5}}{\\triangle x/2}\" /></p><p>We don't know the pressure at the face so we need to remove it so that we have an <em>equivalent</em> permeability/viscosity factor that accounts for both cells. Luckily, we know K and mu in both cells so we can do some algebra to get the velocity across the face in terms of the adjacent cell pressures:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?u_{i+0.5}\\;=\\;-\\dfrac{f_i%20f_{i+1}}{f_i+f_{i+1}}(P_{i+1}-P_i),\\;\\;\\;\\;\\;f_i&space;=&space;%20\\dfrac{K_{i}}{\\mu_{i}}\\dfrac{1}{x_{i+0.5}-x_i}\" /></p><p>This expression will take care of all interior faces.</p><p>I wrote at the beginning that the continuity equation would allow use to solve for the pressure distribution, then combined it with Darcy's law. How does that work with our conception so far? Well, conservation of mass in a 1D mesh, assuming a constant cross-sectional area (i.e. all the faces have the same area), dictates that the velocity at both faces of cell <em>i</em> be equal to each other:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?u_{i-0.5}\\;=\\;u_{i+0.5}\" /></p><p>We can combine this with the preceding equation to get our pressure relations. Since the cell of interest is cell <em>i</em>, we need <em>P<sub>i</sub></em> on one side and all the other terms on the other side:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?P_i\\;=\\;\\dfrac{\\dfrac{f_{i+1}f_i}{f_{i+1}+f_i}P_{i+1}+\\dfrac{f_{i-1}f_i}{f_{i-1}+f_i}P_{i-1}} {\\dfrac{f_{i+1}f_i}{f_{i+1}+f_i}+\\dfrac{f_{i-1}f_i}{f_{i-1}+f_i}}\" /></p><p>At the boundaries, the pressures are given so the boundary cells have slightly different terms: the inner faces are interior faces so their factors don't change. For the outer (boundary) faces, the pressure at the face is known so the velocity calculation is easy there. For the most left cell (at origin), <em>P<sub>i</sub></em> is calculated as:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?P_i\\;=\\;\\dfrac{\\dfrac{f_{i+1}f_i}{f_{i+1}+f_i}P_{i+1}+f_iP_0}{\\dfrac{f_{i+1}f_i}{f_{i+1}+f_i}+f_i}\" /></p><h3 id=\"basic-solution-using-gauss-seidel\">Basic Solution using Gauss-Seidel</h3><p>We have equations for the pressure of each cell in terms of each other, thereby creating a system of algebraic equations. If we had 3 or 4, we could solve them by hand by plugging in pressures we know for equations we don't. But that gets less efficient the finer the mesh becomes. That being said, the system of equations we have now allows us to debug in a straightforward manner by checking each individual calculation. Let's use that to our advantage now and use some more sophisticated methods later.</p><p>The most straightforward method I can think of to solve a system of algebraic equations is the <a href=\"https://en.wikipedia.org/wiki/Gauss%E2%80%93Seidel_method\">Gauss-Seidel method</a>. Skipping to the end, you substitute values of variables you do know forward into equations you do not. So, in our case, we know the inlet pressure (<em>P<sub>0</sub></em>) so we can use that to find the pressure at the adjacent cell center <em>P<sub>1</sub></em>. Notice though, that the pressure at that cell is also a function of the pressure at the next cell <em>P<sub>2</sub></em> that we do not know. So, we have a to make an initial guess then calculate this once or even multiple times. More reading is available at Gauss-Seidel’s <a href=\"https://en.wikipedia.org/wiki/Gauss%E2%80%93Seidel_method\">wiki</a> but some important points are:</p><ul>  <li>Gauss-Seidel is an iterative method requiring repeated solution of the same equations with changing variables</li>  <li>Solutions (should<sup id=\"fnref:GS\" role=\"doc-noteref\"><a href=\"#fn:GS\" class=\"footnote\" rel=\"footnote\">1</a></sup>) improve with successive iterations until error is below some tolerance (convergence)</li>  <li>The number of iterations it takes to convergence depends on the quality of the initial guess</li></ul><p>So we've prepped the math, let's jump to the code. First, the pseudocode:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># Solver Parameterstol = 1E-6 # tolerance to determining stopping point of schemeres = 1.0 # residual (initially greater than the tolerancemax_iter = 1000 # max iterations (so it doesn't go forever)k = 0 # iteration counter## Initializep[2:N-1] = zeros(N-2,1) # initial guess for cell centers## Iteration Loopdo while ((res&gt;tol)&amp;&amp;(k&lt;max_iter))  p_prev = p # previous iteration  for i in range(1,N-1)    Aw = ... # \"west\" factor (i-1)\tAe = ... # \"east\" factor (i+1)\tAp = Aw + Ae # center factor (i)    p[i] = (Aw*p[i-1] + Ae*p[i+1])/Ap  end  res = sum(abs(p-p_prev)) # L2 norm of p_diff  k += 1 # increase iteration countend do</code></pre></div></div><p>We first define the solver parameters: tol and max_iter define how soon the iteration loop terminates, depending either on convergence (tol) or a maximum iteration count. res and k represents how the scheme is doing and whichever reaches its limit sooner terminates the loop. Then, we initialize the middle mesh points’ solution. Since we have pressure boundaries, p[0] and p[N-1] are already solved. Since we do not know how many iterations it will take to get a converged pressure, we use a while loop as the outer loop with the residual as the main escape condition. The iteration count is insurance so the program doesn’t hang here.</p><p>Inside the loop, the Gauss-Seidel method allows the use of the next iteration’s solution (p[i+1], p[i-1]) so the equations are are continually changing based on new data. There is another simple iterative method called the Jacobi method where the previous iteration’s solution (p_prev in the pseudocode) is used to calculate the next iteration. The difference then becomes convergence speed, where Gauss-Seidel is generally faster.</p><p>So what does this look like in Python? Not too different from the pseudocode but it is adjusted for better debugging:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>def gauss_seidel(self,msh,pm): # need the mesh info and porous medium permeability        # Solver Parameters        tol = 1E-6 # tolerance to determining stopping point of scheme        res = np.array([1.0],dtype=float) # residual (initially greater than the tolerance        max_iter = 100 # max iterations (so it doesn't go forever)        k = 0 # iteration counter        # self.p[2:N-1] = zeros(N-2,1) # initial guess for cell centers        p_samp = np.zeros([1,4],dtype=float)        p_samp[0][:] = np.copy([self.p[1],self.p[3],self.p[msh.Nx-4],self.p[msh.Nx-2]])        # p_samp[0][0] = np.copy(self.p[1])        # p_samp[0][1] = np.copy(self.p[3])        # p_samp[0][2] = np.copy(self.p[msh.Nx-4])        # p_samp[0][3] = np.copy(self.p[msh.Nx-2])                ## Iteration Loop        while ((res[k]&gt;tol)and(k&lt;max_iter)):            p_prev = np.copy(self.p)# previous iteration (copy to avoid using same mem loc)            i = 1 # first cell center            fw = -pm.K[i]/self.mu[i]/(msh.x[i]-msh.xc[i]) # f_i-1/2 -&gt; f_i            fe = -pm.K[i]/self.mu[i]/(msh.xc[i+1]-msh.x[i]) # f_i -&gt; f_i+1/2            fee = -pm.K[i+1]/self.mu[i+1]/(msh.x[i+1]-msh.xc[i+1]) #f_i+1/2 -&gt; f_i+1            Aw = fw            Ae = fe*fee/(fe+fee)            self.p[i] = (Aw*self.p[i-1] + Ae*self.p[i+1])/(Aw + Ae)            for i in range(2,msh.Nx-2):                fww = -pm.K[i-1]/self.mu[i-1]/(msh.xc[i]-msh.x[i-1]) # f_i-1-&gt;i-1/2                fw = -pm.K[i]/self.mu[i]/(msh.x[i]-msh.xc[i]) # f_i-1/2 -&gt; f_i                fe = -pm.K[i]/self.mu[i]/(msh.xc[i+1]-msh.x[i]) # f_i -&gt; f_i+1/2                fee = -pm.K[i+1]/self.mu[i+1]/(msh.x[i+1]-msh.xc[i+1]) # f_i+1/2 -&gt; f_i+1                Aw = fw*fww/(fw+fww) # \"west\" factor (i-1 -&gt; i)                Ae = fe*fee/(fe+fee) # \"east\" factor (i -&gt; i+1)                self.p[i] = (Aw*self.p[i-1] + Ae*self.p[i+1])/(Aw + Ae)            i = msh.Nx-2 # last cell center            fww = -pm.K[i-1]/self.mu[i-1]/(msh.xc[i]-msh.x[i-1]) # f_i-1-&gt;i-1/2            fw = -pm.K[i]/self.mu[i]/(msh.x[i]-msh.xc[i]) # f_i-1/2 -&gt; f_i            fe = -pm.K[i]/self.mu[i]/(msh.xc[i+1]-msh.x[i]) # f_i -&gt; f_i+1/2            Aw = fw*fww/(fw+fww)             Ae = fe             self.p[i] = (Aw*self.p[i-1] + Ae*self.p[i+1])/(Aw + Ae)            p_samp = np.append(p_samp,[[self.p[1],self.p[3],self.p[msh.Nx-4],self.p[msh.Nx-2]]],axis=0)            res = np.append(res,[sum(abs(self.p-p_prev))]) # L2 norm of p_diff            k += 1 # increase iteration count            # print(k,res[k-1])                    # Iterations are complete. Now for output        print('Gauss-Seidel Complete. Iteration, Residual:',k,res[k])                # I suggest using the pandas library for output to file. Compare the code below to the output        # function coded from scratch in the mesh class        res_vec = res[:,np.newaxis]        df = pd.DataFrame(np.append(res_vec,p_samp,axis=1),columns=['res','x1','x3','x_N-4','x_N-2'])        df.to_csv('GS_Out.csv',sep='\\t')               return [k,res[k]]</code></pre></div></div><p>The solver parameters remain the same but I've added a pressure sampling array so that I can look at some exact numbers at different iterations. The coefficients Ae and Aw have also been constructed from factors representing what happens in halves of cells: fww represents the right half of the left cell, fw represents the left half of the center cell, and so on. The outermost cells have their pressures calculated outside of the loop, acknowledging that their outer faces are actually boundaries.  After the iteration loop, I report some data to the terminal (through print) and to a csv file through a pandas function. I hope you notice the much shorter code for outputting to a file with pandas compared to the scratch function in the mesh class. My recommendation: if you can't help fighting with your code, find tools that help you avoid those debugging battles.</p><p>Since we're object-oriented, we can call this method quite easily using:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>## Pressure calculation using Gauss-Seidelfl_gs = fluid(base_mesh,base.fl)print('Original P:',fl_gs.p[0:4],      fl_gs.p[base_mesh.Nx-5:base_mesh.Nx-1])&gt;&gt;&gt; Original P: [0. 0. 0. 0.] [0. 0. 0. 0.][itera, res] = fl_gs.gauss_seidel(base_mesh,pm1)print('Gauss-Seidel P:',fl_gs.p[0:4],      fl_gs.p[base_mesh.Nx-5:base_mesh.Nx-1])&gt;&gt;&gt; Gauss-Seidel Complete. Iteration, Residual: 100 5.65338582708514&gt;&gt;&gt; Gauss-Seidel P: [ 0.         -0.00138227 -0.00462155 -0.00872932] [-80.27557742 -85.87430752 -91.51599336 -97.17199779]</code></pre></div></div><p>Remembering our desired solution, it seems the scheme is way off. What's  going on? Remember, Gauss-Seidel is an iterative method, meaning it gets closer and closer to its solution with each iteration. We can run it 2 more times and compare the pressures to see this process:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>[itera, res] = fl_gs.gauss_seidel(base_mesh,pm1)print('Gauss-Seidel P:',fl_gs.p[0:4],      fl_gs.p[base_mesh.Nx-5:base_mesh.Nx-1])fl_gs2 = copy.deepcopy(fl_gs) # another 100 iterations[itera, res] = fl_gs2.gauss_seidel(base_mesh,pm1)fl_gs3 = copy.deepcopy(fl_gs2) # another 100 iterations[itera, res] = fl_gs3.gauss_seidel(base_mesh,pm1)&gt;&gt;&gt; Plotting Code Here. Refer to Gauss_Seidel_Solve.py in Github Repo &lt;&lt;&lt;</code></pre></div></div><p><img src=\"../../../assets/images/p_comp.png\" alt=\"Comparison Plot of P: True solution vs. GS.\" title=\"Pressure vs. x.\" /></p><p>The initial condition is the zero condition, which is good for the inlet but  far from the outlet solution. Since the solutions of individual nodes are determined by the neighbor, getting the final solution using this iterative method requires “communication” between the nodes, and it takes a while for this to occur.So, at the very least, it is moving towards the correct solution, iteration by iteration. But this isn't an efficient way of solving it. Giving a better initial condition would definitely help and using better solution algorithms/methods can help. The successive over-relaxation (SOR) method takes a small step from the Gauss-Seidel method but, with some matrix set-up, I recommend using a direct solver.</p><p>In any case, our code/method works. It took some work to get here so let's try a problem that we don't know the answer to. Assume the viscosity changes linearly according to:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?\\mu\\;=\\;gx+b\" /></p><p>where <em>g</em> and <em>b</em> are constants. In truth, we can do some calculus and differential equation work to get the solution but, at first glance, it's not apparent what the solution should be. Even if you don't want to do the math, you can check the pressure solution by simply calculating the velocities at the faces to ensure they are constant.</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>class fluid():...    def mu_lin(self,mesh):        N = mesh.Nx        L = mesh.x[N-1]        L0 = mesh.x[0]        for i in range(1,N):            self.mu[i] = (0.005-0.001)/(L-L0)*mesh.x[i]+0.001...fl_gs_mulin = fluid(base_mesh,base.fl)print('Original P:',fl_gs_mulin.p[0:4],      fl_gs_mulin.p[base_mesh.Nx-5:base_mesh.Nx-1])fl_gs_mulin.p_lin(base_mesh)print('Linear P:',fl_gs_mulin.p[0:4],      fl_gs_mulin.p[base_mesh.Nx-5:base_mesh.Nx-1])fl_gs_mulin.mu_lin(base_mesh)for k in range(0,51): [itera, res] = fl_gs_mulin.gauss_seidel(base_mesh,pm1)print('Final P:',fl_gs_mulin.p[0:4],      fl_gs_mulin.mu[base_mesh.Nx-5:base_mesh.Nx-1])&gt;&gt;&gt; Original P: [0. 0. 0. 0.] [0. 0. 0. 0.]&gt;&gt;&gt; Linear P: [ 0. -1. -3. -5.] [-93. -95. -97. -99.]...&gt;&gt;&gt; Gauss-Seidel Complete. Iteration, Residual: 1 9.391120880941628e-08&gt;&gt;&gt; Final P: [ 0.         -0.33986983 -1.05987099 -1.83320556] [0.00472 0.0048  0.00488 0.00496].&gt;&gt;&gt; Code to Plot mu, p, and u, also in the Gauss_Seidel_Solve.py file in Github Repo &lt;&lt;&lt;</code></pre></div></div><p><img src=\"../../../assets/images/node_conv_mu_P.png\" alt=\"mu and converged P for GS and linear viscosity.\" title=\"mu/P vs. x.\" /></p><p>The pressure distribution is different now, but of course, the changing viscosity means that the pressure distribution must be higher in some places to maintain the same velocity throughout (remember, continuity equation/conservation of mass). This is reflected in the constant velocity profile shown below:</p><p><img src=\"../../../assets/images/face_conv_u.png\" alt=\"converged u for GS and linear viscosity.\" title=\"u vs. x.\" /></p><p>In the next blog post, we'll use more efficient extant tools to solve this problem.</p><h4 id=\"footnotes\">Footnotes</h4><div class=\"footnotes\" role=\"doc-endnotes\">  <ol>    <li id=\"fn:GS\" role=\"doc-endnote\">      <p>To solve a linear system using the Gauss-Seidel method (or any of the methods I'll be discussing), the coefficient matrix needs to be diagonally dominant or symmetric positive definite. Otherwise, the code will not converge to a solution. This is a bit technical so just know, for the systems of equations I set up (where solutions at indivdual points are only calculated based on their neighbors), the matrices are always diagonally dominant. I urge caution before trying to use this on a linear system with random values or some “easy” linear system coming from a textbook. <a href=\"#fnref:GS\" class=\"reversefootnote\" role=\"doc-backlink\">&#8617;</a></p>    </li>  </ol></div>",
            "url": "tim-munuhe.github.io/2021/06/07/solve-1d-darcy-continuity",
            
            
            
            
            
            "date_published": "2021-06-07T00:00:00-04:00",
            "date_modified": "2021-06-07T00:00:00-04:00",
            
                "author":  {
                "name": "Timothy W. Munuhe, Ph.D.",
                "url": "tim-munuhe.gitub.io",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "tim-munuhe.github.io/2021/05/14/mesh-fluidpm-plot",
            "title": "Basic Python with Darcy's Law - Meshing, Basic Spatial Solutions, and Plotting Output",
            "summary": "Form the mesh objects, calculate a basic solution over the mesh, and plot the output.",
            "content_text": "Now that we have some practice with objects in Python and Darcy’s law, we can create a program that is more expandable and useful. Since this is a physical problem, we need to consider space in our code. So, we need to add a mesh to represent the porous medium and the fluid inside its pores. We also need to output data as plots for immediate review and in a way that other programs can read.More classes and objects can get unwieldy, so let's develop a sketch of how the program is going to work overall so we can code effectively. First, a text description: the user (you, or me) is going to create a case file that the csv.Dictreader function will read into Python listing case parameters.  A case object will be instantiated using that data just read. This is as far as we got in the previous post. Now, we can create a mesh (object) representing the space filled with the fluid (object) and solid material/matrix (object). All three objects' parameters will be determined by that parameters specified in the case file. Since the fluid is the only one flowing, Darcy's Law will be called on it to calculate the pressure and flow velocity at the locations specified by the mesh. Lastly, relevant properties will be output to a file that the user can plot or analyze.Simple, right? Remember, one step at a time.The MeshThe mesh can represent a 1D, 2D, or 3D space. Assume we have a cylindrical pipe filled with sand and water. Depending on its width, diameter, and how homogeneous the sand is, we might want to consider it in 3D or 2D. If we also assume the pipe is very long relative to its diameter, we can simplify the problem to 1D. A 1D mesh is essentially a line with points along it while the 2D and 3D spaces can be divided into a variety of 2D and 3D shapes (squares and cubes being particularly common). So, each element of the 1D mesh represents a slice of the pipe.I'll be using finite difference method for the majority of the blog posts. There's more math here than I care to dig into but I recommend reading Patankar &amp; Spalding’s 1972 paper titled “A Calculation Procedure for Heat, Mass, and Momentum Transfer”. In short, from Darcy’s Law, the pressure gradient is used to calculate the velocity. So, the velocity and pressure are more accurately considered at offset locations, for example on a staggered mesh. That is, where you calculate the velocity is offset from where you calculate the pressures. So, you use the pressures at two adjacent cells to calculate the (volume-averaged) velocity at the face between those cells. You can do this to get the velocities at the interior faces. At the inlet and outlet, the inlet pressure and velocity are collocated which may affect the accuracy. That is not important for the current code but, for better-than-1st-order accuracy, we'd need to derive a better approximation for the pressure gradients there. In any case, CFD-Online has a pretty short article about the staggered grid issue.Back to the OOP: we create a mesh class where each mesh object has a name, shape, density, and specified node (x), interior face (xc), and boundary locations (also xc):class mesh(): # mesh class    def __init__(self,case): # Take in the case info for certain params        dim = 1 # case.dim        if (dim == 1):            self.Nx = int((case.xL - case.x0)/case.dx + 2.0)                    # Face locations            self.xc = np.ones(self.Nx)*case.x0# Initialize mesh            self.xc[self.Nx-1] = case.xL # Outward boundary            for i in range(2,self.Nx-1):                 self.xc[i] = (i-1)*case.dx # Cell Face Locations            # Node locations            self.x = np.copy(self.xc) # Initialize mesh            for i in range(0,self.Nx-1):                self.x[i] = (self.xc[i+1] + self.xc[i])/2 # Cell Node Locations: halfway between faces            self.x[self.Nx-1] = np.copy(self.xc[self.Nx-1]) # Outward boundary        def output(self,fname): # output mesh        with open(fname,'w', newline='') as csvfile:            mesh_write = csv.writer(csvfile,dialect = 'excel', delimiter = '\\t') # writer object            mesh_write.writerow(['i', 'x', 'xc']) # header row            for i in range(0,self.Nx):                mesh_write.writerow([i+1,self.x[i],self.xc[i]]) # actual data rowsThe mesh consists of nodes and faces: the number of nodes is the number of slices the make the pipe plus 2. Why the plus 2? There are two additional nodes at the inlet and outlet. There is one less face but, to keep the indices and array lengths the same, the inlet face is duplicated. This helps with coding and that first face can be ignored for the most part. The mesh requires a case object for its instantiation, so we create the mesh object using base_mesh = mesh(base). Let’s ask for some information, just to make sure everything ran smoothly:print('Node Locations w/ inlet:', base_mesh.x[0:5]) # check inlet location and spacingprint('Nx:', base_mesh.Nx) # check number of elementsprint('Outlet Location:', base_mesh.x[base_mesh.Nx-1])print('Face Locations:', base_mesh.xc[0:5]) &gt;&gt;&gt; Node Locations w/ inlet: [0.   0.01 0.03 0.05 0.07]&gt;&gt;&gt; Nx: 52&gt;&gt;&gt; Outlet Location: 1.0&gt;&gt;&gt; Face Locations: [0.   0.   0.02 0.04 0.06]The number of elements is correct, the inlet face is duplicated, and the spacing for the interior node locations is correct. For the calculations to follow, we just have to remember the offset between the node and face indices for our accuracy. Now we can output this to a file that another program can use, maybe for visualization, by calling the output method that's also in the mesh class: base_mesh.output('base_mesh.dat')If everything works, the first six lines of your .dat file will be:i\tx\txc1\t0.0\t0.02\t0.01\t0.03\t0.03\t0.024\t0.05\t0.045\t0.07\t0.06If you’re using excel, you can output a csv file: go to the Data tab and do text-to-columns on all the rows with a tab delimiter to get it formatted.Applying Darcy's Law as a Method to a Fluid ObjectBecause the porous medium and fluid occupy the space of the mesh, they need to have some of the same properties as the mesh, namely the shape and spatial positions of the mesh. Then, the pressure at p[i] is the pressure at the location x[i]. Apart from the size and shape, the fluid and porous medium share a pressure and have their own properties as outlined in Darcy's Law. Both have their own names and volume fractions. The fluid will have a viscosity and velocity and the porous medium will have a permeability:class fluid(): # fluid class, can create multiple fluid objects for multiphase flow or other studies    def __init__(self,mesh,fluid_prop):        self.name = fluid_prop['Name']        # Initialize variables        self.p = np.ones(mesh.Nx)*fluid_prop['p0'] # Pressure        self.p[mesh.Nx-1] = fluid_prop['pL'] # Pressure boundary at x = L        self.u = np.ones(mesh.Nx)*fluid_prop['u0'] # Velocity: Staggered mesh so velocity at faces        self.mu = np.ones(mesh.Nx)*fluid_prop['mu'] # Viscosity    def p_lin(self,mesh):        N = mesh.Nx        L = mesh.x[N-1]        L0 = mesh.x[0]        for i in range(1,N):            self.p[i] = (self.p[N-1]-self.p[0])/(L-L0)*mesh.x[i]    def darcyv(self,mesh,pm):        N = mesh.Nx        self.u[0] = -pm.K[0]/self.mu[0]*(self.p[1]-self.p[0])/(mesh.x[1]-mesh.x[0]) # inlet        self.u[1] = self.u[0] # same location        for i in range(2,N-1): # interior faces            Ai = pm.K[i-1]/self.mu[i-1]/(mesh.xc[i]-mesh.x[i-1])            Ai1 = pm.K[i]/self.mu[i]/(mesh.x[i]-mesh.xc[i])            self.u[i] = -Ai*Ai1/(Ai+Ai1)*(self.p[i]-self.p[i-1])        self.u[N-1] = -pm.K[N-1]/self.mu[N-1]*(self.p[N-1]-self.p[N-2])/(mesh.x[N-1]-mesh.x[N-2]) # outletclass por_med(): # porous medium class, for parametric studies or composite porous media    def __init__(self,mesh,pm_prop):        self.name = pm_prop        # Initialize Variables        self.K = np.ones(mesh.Nx)*pm_prop['K'] # Permeability        self.eps = np.ones(mesh.Nx)*pm_prop['eps'] # Porosity...fl1 = fluid(base_mesh,base.fl) # fluid object, determined by mesh and case's fluid propertiespm1 = por_med(base_mesh,base.pm) # porous medium object, determined by mesh and case's porous medium propertiesWith the fluid and porous medium objects created, we can find the pressures and flow velocities within the domain at the points specified by the mesh. While we can do something similar to the direct calculation in in the first blog post, let’s create methods so that the functions are tied to the specific objects. This connects the equations to the specific parts of the problem more directly.Since the porous medium is homogeneous, we can assume that the pressure distribution in the porous medium is linear, with the boundary conditions in the case corresponding to the inlet and outlet pressures. Then, we can code a very simple pressure calculation method for the fluid below the instantiation, represented by the p_lin(mesh) method in the fluid class above:print('Initial Pressure:',fl1.p[0:4])fl1.p_lin(base_mesh)print('Linear Pressure:',fl1.p[0:4])&gt;&gt;&gt; Initial Pressure: [0. 0. 0. 0.]&gt;&gt;&gt; Linear Pressure: [ 0. -1. -3. -5.]At the faces (represented by xc) we can then calculate the velocities using the Darcy’s Law method also in the fluid class:print('Initial Velocity (correct):',fl1.u[0:4]) # velocity from initializationfl1.u = np.zeros(base_mesh.Nx) # zero out velocity fl1.darcyv(base_mesh,pm1) # use darcyv methodprint('Final Velocity:',fl1.u[0:4]) # print to confirm that darcyv did what it was supposed to (got same solution as initialization)&gt;&gt;&gt; Initial Velocity (correct): [1.e-04 1.e-04 1.e-04 1.e-04]&gt;&gt;&gt; Final Velocity: [1.e-04 1.e-04 1.e-04 1.e-04]The darcyv method as it is coded looks complicated but it's pretty simple mathematically. The changes made from just applying Darcy's law from the previous post (-K/mu*dP/dx) directly allow it to handle nonhomogeneous porous media and meshes of varying element size, which we might want to do later.Matplotlib OutputWe’ve already gone over outputting results to data. What if you just want some quick results to confirm that everything makes sense? With 1D data, creating line plots will give us faster results. To let us know whether everything went well.The class formation format we’ve used so far has been somewhat cumbersome due to all the parameters. Now, I just want to collect the solution to be output to an object that I can pass to a plotting function. To make the solution object, I can use metaprogramming with the type function:data_sol = type('sol', (object,), {})() # empty object (metaprogramming)data_sol.Np = 3 # Data at nodes: x p, K, mudata_sol.Nx = base_mesh.Nxdata_sol.varnamex = 'x (m)'data_sol.varname = ['p (Pa)', 'K ($m^2$)', '\\u03BC (Pa*s)']data_sol.x = base_mesh.xdata_sol.var = np.zeros((data_sol.Nx,data_sol.Np))data_sol.var = np.concatenate((fl1.p.reshape(data_sol.Nx,1)                               ,pm1.K.reshape(data_sol.Nx,1)                               ,fl1.mu.reshape(data_sol.Nx,1))                              ,axis=1)Here, I've created a new sol object data_sol that is initially empty. I’ve then filled it with the data I need to output and visualize, namely the pressure, permeability, and viscosity which are at the nodes. I want the velocity too but I need a different object to handle the variables calculated at the face. Corresponding code is in the Github repo for this. For now, let's focus on the plot. I can pass this sol object to a function that knows how to read it and create plots:def plot_out(data): # plotting function, takes in data object of specific form and prints plots    N_param = data.Np    N = data.Nx    fig, ax = plt.subplots(N_param,1,figsize=(4,5))        for i in range(0,N_param):        ax[i].plot(data.x, data.var[0:,i], color = 'black',linewidth=0.5)        ax[i].set_xlabel(data.varnamex,fontsize=12)         ax[i].set_ylabel(data.varname[i],fontsize=12)    fig.tight_layout()    plt.show()  ....plot_out(data_sol) # call the plotting outputNow that we can output text and figures to check our results, we can use more sophisticated numerical methods to get solutions to more complicated problem while debugging more efficiently.",
            "content_html": "<p>Now that we have some practice with objects in Python and Darcy’s law, we can create a program that is more expandable and useful. Since this is a physical problem, we need to consider space in our code. So, we need to add a mesh to represent the porous medium and the fluid inside its pores. We also need to output data as plots for immediate review and in a way that other programs can read.</p><p>More classes and objects can get unwieldy, so let's develop a sketch of how the program is going to work overall so we can code effectively. First, a text description: the user (you, or me) is going to create a case file that the csv.Dictreader function will read into Python listing case parameters.  A case object will be instantiated using that data just read. This is as far as we got in the previous post. Now, we can create a mesh (object) representing the space filled with the fluid (object) and solid material/matrix (object). All three objects' parameters will be determined by that parameters specified in the case file. Since the fluid is the only one flowing, Darcy's Law will be called on it to calculate the pressure and flow velocity at the locations specified by the mesh. Lastly, relevant properties will be output to a file that the user can plot or analyze.</p><p>Simple, right? Remember, one step at a time.</p><h3 id=\"the-mesh\">The Mesh</h3><p>The mesh can represent a 1D, 2D, or 3D space. Assume we have a cylindrical pipe filled with sand and water. Depending on its width, diameter, and how homogeneous the sand is, we might want to consider it in 3D or 2D. If we also assume the pipe is very long relative to its diameter, we can simplify the problem to 1D. A 1D mesh is essentially a line with points along it while the 2D and 3D spaces can be divided into a variety of 2D and 3D shapes (squares and cubes being particularly common). So, each element of the 1D mesh represents a slice of the pipe.</p><p>I'll be using finite difference method for the majority of the blog posts. There's more math here than I care to dig into but I recommend reading Patankar &amp; Spalding’s 1972 paper titled “A Calculation Procedure for Heat, Mass, and Momentum Transfer”. In short, from Darcy’s Law, the pressure gradient is used to calculate the velocity. So, the velocity and pressure are more accurately considered at offset locations, for example on a staggered mesh. That is, where you calculate the velocity is offset from where you calculate the pressures. So, you use the pressures at two adjacent cells to calculate the (volume-averaged) velocity at the face between those cells. You can do this to get the velocities at the interior faces. At the inlet and outlet, the inlet pressure and velocity are collocated which may affect the accuracy. That is not important for the current code but, for better-than-1st-order accuracy, we'd need to derive a better approximation for the pressure gradients there. In any case, <a href=\"https://www.cfd-online.com/Wiki/Staggered_grid\">CFD-Online has a pretty short article about the staggered grid issue</a>.</p><p>Back to the OOP: we create a mesh class where each mesh object has a name, shape, density, and specified node (x), interior face (xc), and boundary locations (also xc):</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>class mesh(): # mesh class    def __init__(self,case): # Take in the case info for certain params        dim = 1 # case.dim        if (dim == 1):            self.Nx = int((case.xL - case.x0)/case.dx + 2.0)                    # Face locations            self.xc = np.ones(self.Nx)*case.x0# Initialize mesh            self.xc[self.Nx-1] = case.xL # Outward boundary            for i in range(2,self.Nx-1):                 self.xc[i] = (i-1)*case.dx # Cell Face Locations            # Node locations            self.x = np.copy(self.xc) # Initialize mesh            for i in range(0,self.Nx-1):                self.x[i] = (self.xc[i+1] + self.xc[i])/2 # Cell Node Locations: halfway between faces            self.x[self.Nx-1] = np.copy(self.xc[self.Nx-1]) # Outward boundary        def output(self,fname): # output mesh        with open(fname,'w', newline='') as csvfile:            mesh_write = csv.writer(csvfile,dialect = 'excel', delimiter = '\\t') # writer object            mesh_write.writerow(['i', 'x', 'xc']) # header row            for i in range(0,self.Nx):                mesh_write.writerow([i+1,self.x[i],self.xc[i]]) # actual data rows</code></pre></div></div><p>The mesh consists of nodes and faces: the number of nodes is the number of slices the make the pipe plus 2. Why the plus 2? There are two additional nodes at the inlet and outlet. There is one less face but, to keep the indices and array lengths the same, the inlet face is duplicated. This helps with coding and that first face can be ignored for the most part. The mesh requires a case object for its instantiation, so we create the mesh object using <code class=\"language-python\">base_mesh = mesh(base)</code>. Let’s ask for some information, just to make sure everything ran smoothly:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>print('Node Locations w/ inlet:', base_mesh.x[0:5]) # check inlet location and spacingprint('Nx:', base_mesh.Nx) # check number of elementsprint('Outlet Location:', base_mesh.x[base_mesh.Nx-1])print('Face Locations:', base_mesh.xc[0:5]) &gt;&gt;&gt; Node Locations w/ inlet: [0.   0.01 0.03 0.05 0.07]&gt;&gt;&gt; Nx: 52&gt;&gt;&gt; Outlet Location: 1.0&gt;&gt;&gt; Face Locations: [0.   0.   0.02 0.04 0.06]</code></pre></div></div><p>The number of elements is correct, the inlet face is duplicated, and the spacing for the interior node locations is correct. For the calculations to follow, we just have to remember the offset between the node and face indices for our accuracy. Now we can output this to a file that another program can use, maybe for visualization, by calling the output method that's also in the mesh class: <code class=\"language-python\">base_mesh.output('base_mesh.dat')</code></p><p>If everything works, the first six lines of your <a href=\"https://github.com/tim-munuhe/Basic-Python-Darcys-Law/blob/main/Meshing_SpatialSol_Output/base_mesh.dat\">.dat file</a> will be:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>i\tx\txc1\t0.0\t0.02\t0.01\t0.03\t0.03\t0.024\t0.05\t0.045\t0.07\t0.06</code></pre></div></div><p>If you’re using excel, you can output a csv file: go to the Data tab and do text-to-columns on all the rows with a tab delimiter to get it formatted.</p><h3 id=\"applying-darcys-law-as-a-method-to-a-fluid-object\">Applying Darcy's Law as a Method to a Fluid Object</h3><p>Because the porous medium and fluid occupy the space of the mesh, they need to have some of the same properties as the mesh, namely the shape and spatial positions of the mesh. Then, the pressure at <code class=\"language-python\">p[i]</code> is the pressure at the location <code class=\"language-python\">x[i]</code>. Apart from the size and shape, the fluid and porous medium share a pressure and have their own properties as outlined in Darcy's Law. Both have their own names and volume fractions. The fluid will have a viscosity and velocity and the porous medium will have a permeability:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>class fluid(): # fluid class, can create multiple fluid objects for multiphase flow or other studies    def __init__(self,mesh,fluid_prop):        self.name = fluid_prop['Name']        # Initialize variables        self.p = np.ones(mesh.Nx)*fluid_prop['p0'] # Pressure        self.p[mesh.Nx-1] = fluid_prop['pL'] # Pressure boundary at x = L        self.u = np.ones(mesh.Nx)*fluid_prop['u0'] # Velocity: Staggered mesh so velocity at faces        self.mu = np.ones(mesh.Nx)*fluid_prop['mu'] # Viscosity    def p_lin(self,mesh):        N = mesh.Nx        L = mesh.x[N-1]        L0 = mesh.x[0]        for i in range(1,N):            self.p[i] = (self.p[N-1]-self.p[0])/(L-L0)*mesh.x[i]    def darcyv(self,mesh,pm):        N = mesh.Nx        self.u[0] = -pm.K[0]/self.mu[0]*(self.p[1]-self.p[0])/(mesh.x[1]-mesh.x[0]) # inlet        self.u[1] = self.u[0] # same location        for i in range(2,N-1): # interior faces            Ai = pm.K[i-1]/self.mu[i-1]/(mesh.xc[i]-mesh.x[i-1])            Ai1 = pm.K[i]/self.mu[i]/(mesh.x[i]-mesh.xc[i])            self.u[i] = -Ai*Ai1/(Ai+Ai1)*(self.p[i]-self.p[i-1])        self.u[N-1] = -pm.K[N-1]/self.mu[N-1]*(self.p[N-1]-self.p[N-2])/(mesh.x[N-1]-mesh.x[N-2]) # outletclass por_med(): # porous medium class, for parametric studies or composite porous media    def __init__(self,mesh,pm_prop):        self.name = pm_prop        # Initialize Variables        self.K = np.ones(mesh.Nx)*pm_prop['K'] # Permeability        self.eps = np.ones(mesh.Nx)*pm_prop['eps'] # Porosity...fl1 = fluid(base_mesh,base.fl) # fluid object, determined by mesh and case's fluid propertiespm1 = por_med(base_mesh,base.pm) # porous medium object, determined by mesh and case's porous medium properties</code></pre></div></div><p>With the fluid and porous medium objects created, we can find the pressures and flow velocities within the domain at the points specified by the mesh. While we can do something similar to the direct calculation in in the first blog post, let’s create methods so that the functions are tied to the specific objects. This connects the equations to the specific parts of the problem more directly.</p><p>Since the porous medium is homogeneous, we can assume that the pressure distribution in the porous medium is linear, with the boundary conditions in the case corresponding to the inlet and outlet pressures. Then, we can code a very simple pressure calculation method for the fluid below the instantiation, represented by the <code class=\"language-python\">p_lin(mesh)</code> method in the fluid class above:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>print('Initial Pressure:',fl1.p[0:4])fl1.p_lin(base_mesh)print('Linear Pressure:',fl1.p[0:4])&gt;&gt;&gt; Initial Pressure: [0. 0. 0. 0.]&gt;&gt;&gt; Linear Pressure: [ 0. -1. -3. -5.]</code></pre></div></div><p>At the faces (represented by <code class=\"language-python\">xc</code>) we can then calculate the velocities using the Darcy’s Law method also in the fluid class:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>print('Initial Velocity (correct):',fl1.u[0:4]) # velocity from initializationfl1.u = np.zeros(base_mesh.Nx) # zero out velocity fl1.darcyv(base_mesh,pm1) # use darcyv methodprint('Final Velocity:',fl1.u[0:4]) # print to confirm that darcyv did what it was supposed to (got same solution as initialization)&gt;&gt;&gt; Initial Velocity (correct): [1.e-04 1.e-04 1.e-04 1.e-04]&gt;&gt;&gt; Final Velocity: [1.e-04 1.e-04 1.e-04 1.e-04]</code></pre></div></div><p>The <code class=\"language-python\">darcyv</code> method as it is coded looks complicated but it's pretty simple mathematically. The changes made from just applying Darcy's law from the previous post (-K/mu*dP/dx) directly allow it to handle nonhomogeneous porous media and meshes of varying element size, which we might want to do later.</p><h3 id=\"matplotlib-output\">Matplotlib Output</h3><p>We’ve already gone over outputting results to data. What if you just want some quick results to confirm that everything makes sense? With 1D data, creating line plots will give us faster results. To let us know whether everything went well.</p><p>The class formation format we’ve used so far has been somewhat cumbersome due to all the parameters. Now, I just want to collect the solution to be output to an object that I can pass to a plotting function. To make the solution object, I can use metaprogramming with the type function:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>data_sol = type('sol', (object,), {})() # empty object (metaprogramming)data_sol.Np = 3 # Data at nodes: x p, K, mudata_sol.Nx = base_mesh.Nxdata_sol.varnamex = 'x (m)'data_sol.varname = ['p (Pa)', 'K ($m^2$)', '\\u03BC (Pa*s)']data_sol.x = base_mesh.xdata_sol.var = np.zeros((data_sol.Nx,data_sol.Np))data_sol.var = np.concatenate((fl1.p.reshape(data_sol.Nx,1)                               ,pm1.K.reshape(data_sol.Nx,1)                               ,fl1.mu.reshape(data_sol.Nx,1))                              ,axis=1)</code></pre></div></div><p>Here, I've created a new sol object data_sol that is initially empty. I’ve then filled it with the data I need to output and visualize, namely the pressure, permeability, and viscosity which are at the nodes. I want the velocity too but I need a different object to handle the variables calculated at the face. Corresponding code is in the Github repo for this. For now, let's focus on the plot. I can pass this sol object to a function that knows how to read it and create plots:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>def plot_out(data): # plotting function, takes in data object of specific form and prints plots    N_param = data.Np    N = data.Nx    fig, ax = plt.subplots(N_param,1,figsize=(4,5))        for i in range(0,N_param):        ax[i].plot(data.x, data.var[0:,i], color = 'black',linewidth=0.5)        ax[i].set_xlabel(data.varnamex,fontsize=12)         ax[i].set_ylabel(data.varname[i],fontsize=12)    fig.tight_layout()    plt.show()  ....plot_out(data_sol) # call the plotting output</code></pre></div></div><p><img src=\"../../../assets/images/node_data_sol.png\" alt=\"Multi-plot of the face data.\" title=\"Pressure, permeability, and viscosity vs. x.\" /></p><p>Now that we can output text and figures to check our results, we can use more sophisticated numerical methods to get solutions to more complicated problem while debugging more efficiently.</p>",
            "url": "tim-munuhe.github.io/2021/05/14/mesh-fluidpm-plot",
            
            
            
            
            
            "date_published": "2021-05-14T00:00:00-04:00",
            "date_modified": "2021-05-14T00:00:00-04:00",
            
                "author":  {
                "name": "Timothy W. Munuhe, Ph.D.",
                "url": "tim-munuhe.gitub.io",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "tim-munuhe.github.io/2021/05/01/csv-read-parameters",
            "title": "Basic Python with Darcy's Law - User-Defined Parameters",
            "summary": "Read parameters for Darcy's Law from a CSV file.",
            "content_text": "In the previous blog post, I introduced some object-oriented Python by creating a parameter class that initialized a solution to Darcy's law for some default fluid and porous medium. So, just by creating the case, we were done. Now, we want to feed our own properties into Darcy's Law.Let's start with the (easier) parameter problem: we can feed in our own fluid and porous medium properties by adding to the instantiation’s input. Currently, we just have (self) for the initialization. Let's add the length of the porous medium:class case_param():     def __init__(self,L):         self.dim = 1 # dimensions         self.x0 = 0.0 # inlet position         self.xL = self.x0 + L # outlet         fluid_name = 'Water'         mu = 0.001         u0 = 0.0         p0 = 0.0 # inlet pressure         pL = -100.0 # outlet         self.fl = {'Name': fluid_name, 'mu': mu, 'u0': u0, 'p0': p0, 'pL': pL}         pm_name = 'Sand'         K = 1.0E-9         eps = 0.15         self.pm = {'Name': pm_name, 'K':K, 'eps':eps} &gt;br&gt;         self.fl['u0'] = -K/mu*(pL-p0)/(self.xL-self.x0)  When we create the case_param object, we need to give the length in the parentheses, like so:base = case_param(1.0)Then, when we call the case's outlet location, we get our length:print(base.xL) &gt;&gt;&gt; 9.999999999999999e-05   which gives us the same answer as the first blog post:print(base.fl['u0'])  &gt;&gt;&gt; 9.999999999999999e-05   We could keep going this way but we have at least 8 parameters for our case that we'd want to vary: the fluid name, viscosity, inlet and outlet pressure, porous medium name, permeability, porosity, and the length of the domain. Instead, we can use text files or CSV files with specified formats to feed in the case parameters, allowing a more streamlined multi-case process. Let's use CSV: we can create it in Excel and it’s use in Python for Data Science means there will be resources for troublshooting later (;-)).First, import the CSV package:import csv   Next, let’s create our CSV case file using Excel:            case_name      fluid      p0      pL      mu      porous_medium      length      K      eps                  base      water      0.000      -100.000      0.001      sand      1.000      1.00E-09      0.150              long      water      0.000      -100.000      0.001      sand      2.000      1.00E-09      0.150              press      water      100.000      -100.000      0.001      sand      1.000      1.00E-09      0.150              powder      water      0.000      -100.000      0.001      powder      1.000      1.00E-11      0.300              oil      oil      0.000      -100.000      0.060      sane      1.000      1.00E-09      0.150      We can use the csv.reader function and skip the first line to create individual case parameter lists, or, we can use the csv.DictReader function to construct individual case dictionaries:with open('casefile.csv',newline='') as casefile:     casereader = csv.DictReader(casefile)     i = 0     caselist = {}     for row in casereader:            caselist[i] = row         print(row['case_name'], row['fluid'], row['mu']) # check that code works as expected         i += 1 &gt;&gt;&gt; base water 0.001 &gt;&gt;&gt; long water 0.001 &gt;&gt;&gt; press water 0.001 &gt;&gt;&gt; powder water 0.001 &gt;&gt;&gt; oil oil 0.060  DictReader uses the first row of the CSV file as the keys and the subsequent row values are the dictionary entries. The only problem is that all entries are read as strings, which must convert the number variables to floats in the &lt;pre&gt;case_param &lt;/pre&gt; instantiation:class case_param():     def __init__(self,param):         self.name = param['case_name'] # now the name is given inside the case, not as the case's actual name         self.dim = 1 # dimensions         self.x0 = 0.0 # inlet position         self.xL = self.x0 + float(param['length']) # outlet         fluid_name = param['fluid']         mu = float(param['mu'])         u0 = 0.0         p0 = float(param['p0']) # inlet pressure         pL = float(param['pL']) # outlet         self.fl = {'Name': fluid_name, 'mu': mu, 'u0': u0, 'p0': p0, 'pL': pL}         pm_name = param['porous_medium']          K = float(param['K'])         eps = float(param['eps'])         self.pm = {'Name': pm_name, 'K':K, 'eps':eps}          self.fl['u0'] = -K/mu*(pL-p0)/(self.xL-self.x0)  We can initialize the original base case and the oil case and compare the velocities: base = case_param(caselist[0])  oil = case_param(caselist[4])  print(base.fl['u0']  &gt;&gt;&gt; 9.999999999999999e-05  print(oil.fl['u0']  &gt;&gt;&gt; 1.6666666666666667e-06  We can see that the viscous oil slows down the flow, as expected. We haven’t changed the Darcy's Law calculation so we know, at least, that the code is reading the CSV file correctly and initializing the case properly.The next step is to see what is going on between the inlet and outlet, specifically with the pressure.",
            "content_html": "<p>In the previous blog post, I introduced some object-oriented Python by creating a parameter class that initialized a solution to Darcy's law for some default fluid and porous medium. So, just by creating the case, we were done. Now, we want to feed our own properties into Darcy's Law.</p><p>Let's start with the (easier) parameter problem: we can feed in our own fluid and porous medium properties by adding to the instantiation’s input. Currently, we just have <code class=\"language-python\">(self)</code> for the initialization. Let's add the length of the porous medium:</p><pre><code class=\"language-python\">class case_param(): <br />    def __init__(self,L): <br />        self.dim = 1 # dimensions <br />        self.x0 = 0.0 # inlet position <br />        self.xL = self.x0 + L # outlet <br />        fluid_name = 'Water' <br />        mu = 0.001 <br />        u0 = 0.0 <br />        p0 = 0.0 # inlet pressure <br />        pL = -100.0 # outlet <br />        self.fl = {'Name': fluid_name, 'mu': mu, 'u0': u0, 'p0': p0, 'pL': pL} <br />        pm_name = 'Sand' <br />        K = 1.0E-9 <br />        eps = 0.15 <br />        self.pm = {'Name': pm_name, 'K':K, 'eps':eps} &gt;br&gt;         self.fl['u0'] = -K/mu*(pL-p0)/(self.xL-self.x0) </code> </pre><p>When we create the <code class=\"language-python\">case_param</code> object, we need to give the length in the parentheses, like so:</p><pre><code class=\"language-python\">base = case_param(1.0)</code></pre><p>Then, when we call the case's outlet location, we get our length:</p><pre><code class=\"language-python\">print(base.xL) <br />&gt;&gt;&gt; 9.999999999999999e-05  </code> </pre><p>which gives us the same answer as the first blog post:</p><pre><code class=\"language-python\">print(base.fl['u0']) <br /> &gt;&gt;&gt; 9.999999999999999e-05  </code> </pre><p>We could keep going this way but we have at least 8 parameters for our case that we'd want to vary: the fluid name, viscosity, inlet and outlet pressure, porous medium name, permeability, porosity, and the length of the domain. Instead, we can use text files or CSV files with specified formats to feed in the case parameters, allowing a more streamlined multi-case process. Let's use CSV: we can create it in Excel and it’s use in Python for Data Science means there will be resources for troublshooting later (;-)).</p><p>First, import the <code class=\"language-python\">CSV</code> package:</p><pre><code class=\"language-python\">import csv  </code> </pre><p>Next, let’s create our CSV case file using Excel:</p><table>  <thead>    <tr>      <th>case_name</th>      <th>fluid</th>      <th>p0</th>      <th>pL</th>      <th>mu</th>      <th>porous_medium</th>      <th>length</th>      <th>K</th>      <th>eps</th>    </tr>  </thead>  <tbody>    <tr>      <td>base</td>      <td>water</td>      <td>0.000</td>      <td>-100.000</td>      <td>0.001</td>      <td>sand</td>      <td>1.000</td>      <td>1.00E-09</td>      <td>0.150</td>    </tr>    <tr>      <td>long</td>      <td>water</td>      <td>0.000</td>      <td>-100.000</td>      <td>0.001</td>      <td>sand</td>      <td>2.000</td>      <td>1.00E-09</td>      <td>0.150</td>    </tr>    <tr>      <td>press</td>      <td>water</td>      <td>100.000</td>      <td>-100.000</td>      <td>0.001</td>      <td>sand</td>      <td>1.000</td>      <td>1.00E-09</td>      <td>0.150</td>    </tr>    <tr>      <td>powder</td>      <td>water</td>      <td>0.000</td>      <td>-100.000</td>      <td>0.001</td>      <td>powder</td>      <td>1.000</td>      <td>1.00E-11</td>      <td>0.300</td>    </tr>    <tr>      <td>oil</td>      <td>oil</td>      <td>0.000</td>      <td>-100.000</td>      <td>0.060</td>      <td>sane</td>      <td>1.000</td>      <td>1.00E-09</td>      <td>0.150</td>    </tr>  </tbody></table><p>We can use the <code class=\"language-python\">csv.reader</code> function and skip the first line to create individual case parameter lists, or, we can use the <code class=\"language-python\">csv.DictReader</code> function to construct individual case dictionaries:</p><pre><code class=\"language-python\">with open('casefile.csv',newline='') as casefile: <br />    casereader = csv.DictReader(casefile) <br />    i = 0 <br />    caselist = {} <br />    for row in casereader:    <br />        caselist[i] = row <br />        print(row['case_name'], row['fluid'], row['mu']) # check that code works as expected <br />        i += 1 <br />&gt;&gt;&gt; base water 0.001 <br />&gt;&gt;&gt; long water 0.001 <br />&gt;&gt;&gt; press water 0.001 <br />&gt;&gt;&gt; powder water 0.001 <br />&gt;&gt;&gt; oil oil 0.060 </code> </pre><p>DictReader uses the first row of the CSV file as the keys and the subsequent row values are the dictionary entries. The only problem is that all entries are read as strings, which must convert the number variables to floats in the &lt;pre&gt;<code class=\"language-python\">case_param</code> &lt;/pre&gt; instantiation:</p><pre><code class=\"language-python\">class case_param(): <br />    def __init__(self,param): <br />        self.name = param['case_name'] # now the name is given inside the case, not as the case's actual name <br />        self.dim = 1 # dimensions <br />        self.x0 = 0.0 # inlet position <br />        self.xL = self.x0 + float(param['length']) # outlet <br />        fluid_name = param['fluid'] <br />        mu = float(param['mu']) <br />        u0 = 0.0 <br />        p0 = float(param['p0']) # inlet pressure <br />        pL = float(param['pL']) # outlet <br />        self.fl = {'Name': fluid_name, 'mu': mu, 'u0': u0, 'p0': p0, 'pL': pL} <br />        pm_name = param['porous_medium']  <br />        K = float(param['K']) <br />        eps = float(param['eps']) <br />        self.pm = {'Name': pm_name, 'K':K, 'eps':eps} <br />         self.fl['u0'] = -K/mu*(pL-p0)/(self.xL-self.x0) </code> </pre><p>We can initialize the original base case and the oil case and compare the velocities:</p><pre><code class=\"language-python\"> base = case_param(caselist[0]) <br /> oil = case_param(caselist[4]) <br /> print(base.fl['u0'] <br /> &gt;&gt;&gt; 9.999999999999999e-05 <br /> print(oil.fl['u0'] <br /> &gt;&gt;&gt; 1.6666666666666667e-06 </code> </pre><p>We can see that the viscous oil slows down the flow, as expected. We haven’t changed the Darcy's Law calculation so we know, at least, that the code is reading the CSV file correctly and initializing the case properly.</p><p>The next step is to see what is going on between the inlet and outlet, specifically with the pressure.</p>",
            "url": "tim-munuhe.github.io/2021/05/01/csv-read-parameters",
            
            
            
            
            
            "date_published": "2021-05-01T00:00:00-04:00",
            "date_modified": "2021-05-01T00:00:00-04:00",
            
                "author":  {
                "name": "Timothy W. Munuhe, Ph.D.",
                "url": "tim-munuhe.gitub.io",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "tim-munuhe.github.io/2021/04/18/darcys-law",
            "title": "Basic Python with Darcy's Law - Introduction",
            "summary": "Let's begin our Python journey by calculating porous fluid flow.",
            "content_text": "Darcy's law is an equation used to calculate fluid flow through a porous medium under a pressure gradient. It’s also a useful test problem to explore scientific computing with Python from a basic to intermediate level.Darcy's Law can be written as:where  is the superficial flow velocity,  is the hydraulic permeability of the porous medium,  is the viscosity of the liquid, and  is the pressure distribution. All three variables can vary over space. If the problem considered is 2D or 3D, then Darcy's Law becomes a partial differential equation (PDE).PDEs represent a myriad of phenomena mathematically, including heat transfer, electro-magnetism and the price of European options. You can find better discussions elsewhere but some prototypical equations to learn about are Laplace’s equation, Poisson’s equation, the Heat equation, and the Wave equation.Problem SetupLet's say we have a pipe filled with sand. A fluid can flow in the spaces between the individual grains of sand, termed the pores. Depending on how big or small or well-packed the sand grains are, it's easier or harder for the fluid to flow through the pipe. This is represented by . The fluid's viscosity also affects how easily it can flow through the pores (maple syrup? or water? or air?).Basically, the porous medium and fluid flow properties are constant. Let's also assume that the pipe is long enough relative to its diameter that we can assume that pressure only varies significantly along its axis. Then, we can treat this as a 1D problem:So now we have an ordinary differential equation, or ODE. To complete the description of the problem we need 2 boundary conditions. Let's give two boundary conditions:Let's give some properties so we can move on:            Property      Value                                                                                                              Enough Physics. Let's Code!With our current assumptions, the superficial velocity at every point within the pipe is:Then we can solve it quite easily with: K = 1.0E-9 # permeability  mu = 0.001 # viscosity  P_0 = 0.0 # inlet  P_L = -100.0 #outlet  L = 1.0 # pipe length  u = -K/mu*(P_L-P_0)/L  print(u)  &gt;&gt;&gt; 9.999999999999999e-05   Simple, but now I can change the variables and get the velocity immediately. I can even add a bit of extra code to output results and create a sort of solution space examining the effects of different variables. However, the assumptions made to get here are pretty restrictive. What if we want to check the pressure along the pipe? What if the sand is not homogeneous? What if the viscosity of the fluid changes because of temperature? We need a more robust solution.Some basic object-oriented programmingAdmittedly, I'm still learning object-oriented programming so all I can do is write how I understand my code within the paradigm. That being said, the code will work, so take solace in that.I want a more robust code that can take user input and tell the rest of the code how to run. So, I'm going to create a case object. I create a case class:class case_param():     def __init__(self):         self.dim = 1 # dimensions         self.x0 = 0.0 # inlet position         self.xL = 1.0 # outlet         fluid_name = 'Water'         mu = 0.001         u0 = 0.0         p0 = 0.0 # inlet pressure         pL = -100.0 # outlet         self.fl = {'Name': fluid_name, 'mu': mu, 'u0': u0, 'p0': p0, 'pL': pL}         pm_name = 'Sand'         K = 1.0E-9         eps = 0.15         self.pm = {'Name': pm_name, 'K':K, 'eps':eps}  This class, in short, defines case objects through common variables: number of dimensions, inlet and outlet position, and the fluid and porous medium used and their properties. The fluid and porous medium are both represented thorugh dictionaries which other objects or methods can refer to. Let's use it:base = case_param() base.u0 = -base.pm['K']/base.fl['mu']*(base.fl['pL']-base.fl['p0'])/(base.xL-base.x0) print(base.u0) &gt;&gt;&gt; 9.999999999999999e-05  So, we've got the same result as the previous, simpler code. We’ve also created a case object that the other to-be-created code can use. For now, let me compress the code by initializing the superficial velocity in the instantiation (__init__ method):class case_param():     def __init__(self):         self.dim = 1 # dimensions         self.x0 = 0.0 # inlet position         self.xL = 1.0 # outlet         fluid_name = 'Water'         mu = 0.001         u0 = 0.0         p0 = 0.0 # inlet pressure         pL = -100.0 # outlet         self.fl = {'Name': fluid_name, 'mu': mu, 'u0': u0, 'p0': p0, 'pL': pL}         pm_name = 'Sand'         K = 1.0E-9         eps = 0.15         self.pm = {'Name': pm_name, 'K':K, 'eps':eps}         self.fl['u0'] = -K/mu*(pL-p0)/(self.xL-self.x0) base = case_param() print(base.fl['u0']) &gt;&gt;&gt; 9.999999999999999e-05  Later, I'll be able to pass this to a mesh object and Darcy’s law method to create a solution that I can plot and output to CSV.",
            "content_html": "<p>Darcy's law is an equation used to calculate fluid flow through a porous medium under a pressure gradient. It’s also a useful test problem to explore scientific computing with Python from a basic to intermediate level.</p><p>Darcy's Law can be written as:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?\\vec{u}&space;=&space;-\\frac{K}{\\mu}\\nabla&space;P\" /></p><p>where <img src=\"https://latex.codecogs.com/svg.image?\\vec{u}\" alt=\"vel\" /> is the superficial flow velocity, <img src=\"https://latex.codecogs.com/svg.image?K\" alt=\"perm\" /> is the hydraulic permeability of the porous medium, <img src=\"https://latex.codecogs.com/svg.image?\\mu\" alt=\"visc\" /> is the viscosity of the liquid, and <img src=\"https://latex.codecogs.com/svg.image?P\" alt=\"pres\" /> is the pressure distribution. All three variables can vary over space. If the problem considered is 2D or 3D, then Darcy's Law becomes a partial differential equation (PDE).</p><p>PDEs represent a myriad of phenomena mathematically, including heat transfer, electro-magnetism and the price of European options. You can find better discussions elsewhere but some prototypical equations to learn about are Laplace’s equation, Poisson’s equation, the Heat equation, and the Wave equation.</p><h3>Problem Setup</h3><p>Let's say we have a pipe filled with sand. A fluid can flow in the spaces between the individual grains of sand, termed the pores. Depending on how big or small or well-packed the sand grains are, it's easier or harder for the fluid to flow through the pipe. This is represented by <img src=\"https://latex.codecogs.com/svg.image?K\" alt=\"perm\" />. The fluid's viscosity also affects how easily it can flow through the pores (maple syrup? or water? or air?).</p><p>Basically, the porous medium and fluid flow properties are constant. Let's also assume that the pipe is long enough relative to its diameter that we can assume that pressure only varies significantly along its axis. Then, we can treat this as a 1D problem:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?u&space;=&space;-\\dfrac{K}{\\mu}\\dfrac{dP}{dx}\" /></p><p>So now we have an ordinary differential equation, or ODE. To complete the description of the problem we need 2 boundary conditions. Let's give two boundary conditions:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?P(x=0)&space;=&space;P_0\" /></p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?P(x=L)&space;=&space;P_L\" /></p><p>Let's give some properties so we can move on:</p><table>  <thead>    <tr>      <th style=\"text-align: center\">Property</th>      <th style=\"text-align: center\">Value</th>    </tr>  </thead>  <tbody>    <tr>      <td style=\"text-align: center\"><img src=\"https://latex.codecogs.com/svg.image?K\" alt=\"perm\" /></td>      <td style=\"text-align: center\"><img src=\"https://latex.codecogs.com/svg.image?10^{-9}\\;\\frac{m^2}{s}\" alt=\"Kval\" /></td>    </tr>    <tr>      <td style=\"text-align: center\"><img src=\"https://latex.codecogs.com/svg.image?\\mu\" alt=\"visc\" /></td>      <td style=\"text-align: center\"><img src=\"https://latex.codecogs.com/svg.image?0.001\\;Pa\\cdot&space;s\" alt=\"Kval\" /></td>    </tr>    <tr>      <td style=\"text-align: center\"><img src=\"https://latex.codecogs.com/svg.image?P_0\" alt=\"perm\" /></td>      <td style=\"text-align: center\"><img src=\"https://latex.codecogs.com/svg.image?0\\;Pa\" alt=\"Kval\" /></td>    </tr>    <tr>      <td style=\"text-align: center\"><img src=\"https://latex.codecogs.com/svg.image?P_L\" alt=\"perm\" /></td>      <td style=\"text-align: center\"><img src=\"https://latex.codecogs.com/svg.image?-100\\;Pa\" alt=\"Kval\" /></td>    </tr>    <tr>      <td style=\"text-align: center\"><img src=\"https://latex.codecogs.com/svg.image?L\" alt=\"perm\" /></td>      <td style=\"text-align: center\"><img src=\"https://latex.codecogs.com/svg.image?1\\;m\" alt=\"Kval\" /></td>    </tr>  </tbody></table><h3>Enough Physics. Let's Code!</h3><p>With our current assumptions, the superficial velocity at every point within the pipe is:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?u=-\\dfrac{K}{\\mu}\\dfrac{P_L-P_0}{L}\" /></p><p>Then we can solve it quite easily with:</p><pre><code class=\"language-python\"> K = 1.0E-9 # permeability <br /> mu = 0.001 # viscosity <br /> P_0 = 0.0 # inlet <br /> P_L = -100.0 #outlet <br /> L = 1.0 # pipe length <br /> u = -K/mu*(P_L-P_0)/L <br /> print(u) <br /> &gt;&gt;&gt; 9.999999999999999e-05  </code> </pre><p>Simple, but now I can change the variables and get the velocity immediately. I can even add a bit of extra code to output results and create a sort of solution space examining the effects of different variables. However, the assumptions made to get here are pretty restrictive. What if we want to check the pressure along the pipe? What if the sand is not homogeneous? What if the viscosity of the fluid changes because of temperature? We need a more robust solution.</p><h3>Some basic object-oriented programming</h3><p>Admittedly, I'm still learning object-oriented programming so all I can do is write how I understand my code within the paradigm. That being said, the code will work, so take solace in that.I want a more robust code that can take user input and tell the rest of the code how to run. So, I'm going to create a case object. I create a case class:</p><pre><code class=\"language-python\">class case_param(): <br />    def __init__(self): <br />        self.dim = 1 # dimensions <br />        self.x0 = 0.0 # inlet position <br />        self.xL = 1.0 # outlet <br />        fluid_name = 'Water' <br />        mu = 0.001 <br />        u0 = 0.0 <br />        p0 = 0.0 # inlet pressure <br />        pL = -100.0 # outlet <br />        self.fl = {'Name': fluid_name, 'mu': mu, 'u0': u0, 'p0': p0, 'pL': pL} <br />        pm_name = 'Sand' <br />        K = 1.0E-9 <br />        eps = 0.15 <br />        self.pm = {'Name': pm_name, 'K':K, 'eps':eps} </code> </pre><p>This class, in short, defines case objects through common variables: number of dimensions, inlet and outlet position, and the fluid and porous medium used and their properties. The fluid and porous medium are both represented thorugh dictionaries which other objects or methods can refer to. Let's use it:</p><pre><code class=\"language-python\">base = case_param() <br />base.u0 = -base.pm['K']/base.fl['mu']*(base.fl['pL']-base.fl['p0'])/(base.xL-base.x0) <br />print(base.u0) <br />&gt;&gt;&gt; 9.999999999999999e-05 </code> </pre><p>So, we've got the same result as the previous, simpler code. We’ve also created a case object that the other to-be-created code can use. For now, let me compress the code by initializing the superficial velocity in the instantiation (__init__ method):</p><pre><code class=\"language-python\">class case_param(): <br />    def __init__(self): <br />        self.dim = 1 # dimensions <br />        self.x0 = 0.0 # inlet position <br />        self.xL = 1.0 # outlet <br />        fluid_name = 'Water' <br />        mu = 0.001 <br />        u0 = 0.0 <br />        p0 = 0.0 # inlet pressure <br />        pL = -100.0 # outlet <br />        self.fl = {'Name': fluid_name, 'mu': mu, 'u0': u0, 'p0': p0, 'pL': pL} <br />        pm_name = 'Sand' <br />        K = 1.0E-9 <br />        eps = 0.15 <br />        self.pm = {'Name': pm_name, 'K':K, 'eps':eps} <br />        self.fl['u0'] = -K/mu*(pL-p0)/(self.xL-self.x0) <br /><br />base = case_param() <br />print(base.fl['u0']) <br />&gt;&gt;&gt; 9.999999999999999e-05 </code> </pre><p>Later, I'll be able to pass this to a mesh object and Darcy’s law method to create a solution that I can plot and output to CSV.</p>",
            "url": "tim-munuhe.github.io/2021/04/18/darcys-law",
            
            
            
            
            
            "date_published": "2021-04-18T00:00:00-04:00",
            "date_modified": "2021-04-18T00:00:00-04:00",
            
                "author":  {
                "name": "Timothy W. Munuhe, Ph.D.",
                "url": "tim-munuhe.gitub.io",
                "avatar": null
                }
                
            
        }
    
    ]
}