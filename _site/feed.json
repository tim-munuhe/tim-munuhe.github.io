{
    "version": "https://jsonfeed.org/version/1",
    "title": "tim-munuhe",
    "home_page_url": "tim-munuhe.github.io/",
    "feed_url": "tim-munuhe.github.io/feed.json",
    "description": null,
    "icon": "tim-munuhe.github.io/apple-touch-icon.png",
    "favicon": "tim-munuhe.github.io/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "Timothy W. Munuhe, Ph.D.",
        "url": "tim-munuhe.gitub.io",
        "avatar": null
    },
    
"items": [
    
        {
            "id": "tim-munuhe.github.io/2021/11/21/apply-solvers",
            "title": "Basic Python with Darcy's Law - Algorithms to Solve System of Linear Equations",
            "summary": "Implement algorithms to solve system of linear equations created from Darcy\\'s Law and Continuity Equation",
            "content_text": "We have equations for the pressure at every point within the 1D domain, but we’re using a basic method to solve the equations. Here’s some trivia: Gauss mentioned it first in 1823 but the method wasn’t published until Seidel wrote it up in 1874. Since then, many newer methods have been developed to solve linear systems of equations. This post will cover three more commonly used algorithms: Cholesky decomposition, Gauss-Jordan, and the conjugate gradient method.System CharacterizationFirst, let’s consider our system of equations: to find the pressure, we solve only three unique sets of equations: the equations for the cells near the inlet and outlet and the equation for all the cells in the middle. Additionally, the cells’ pressures only depend on the adjacent pressures, of which two are given (inlet and outlet). Such a system can be described in matrix form Ax = b, where A is a coefficient matrix, x is a column vector representing the variables we want to find, and b is a column vector representing the constants in each equation:The inlet and outlet pressures are represented by the top and bottom rows of the matrix and both vectors, respectively. Because they have known pressures, they only have one value in the matrix and the given pressure in the b-vector. All other “internal” pressures depend on their neighboring pressures only. Therefore, their b-vector values are zero and they have three entries in their A-matrix (the left, center, and right cells).One important feature of the matrix: it is symmetric. That is, that the coefficient matrix’s transpose is equal to the matrix itself. We can see this instantly by checking the entries on either side of the top left to bottom right diagonal. Additionally, the matrix is positive definite. This is not as obvious, unless you’ve had prior experience with such a matrix, but it can be checked by conducting Gaussian elimination to get the matrix into upper triangular/row echelon form. Let's get the row-echelon form using Python and NumPy:import numpy as npdef row_reduc(A_org):    N,M = A_org.shape    if (N != M): raise Exception('Matrix must be square! Size:',N,',',M)        # Setup    A = np.copy(A_org)    A_inv = np.eye(N) # A inverse initialized as identity matrix    P_gen = np.eye(N) # General Permutation matrix    P = np.eye(N) # Permutation matrix for this column pivot    # Reduce to upper tridiagonal coefficient matrix    for i in range(0, N-1):        # Find row of pivot element in column i        i_max = i        for j in range(i+1,N):          if (abs(A[i_max,i]) &lt; abs(A[j,i])): i_max = j        if (A[i_max,i] &lt; 0.0):            A[i_max,0:] = A[i_max,0:]*-1.0 # Switch signs            A_inv[i_max,0:] = A_inv[i_max,0:]*-1.0        # Move pivot row so column is on diagonal        if (i_max != i): # Swap rows            P[i_max, i_max] = 0.0            P[i, i] = 0.0            P[i_max, i] = 1.0 # Move row i to row i_max            P[i, i_max] = 1.0 # Move row i_max to row i            A = np.matmul(P,A)            A_inv = np.matmul(P,A_inv)             P_gen = np.matmul(P, P_gen) # !compt. intensive!        # Pivot        fac = A[i,i]        A_inv[i,0:] = A_inv[i,0:]/fac        A[i,0:] = A[i,0:]/fac # pivot element becomes 1        for j in range(i+1,N): # Other rows            if  (A[j,i] != 0.0): # skip rows with column element = 0                fac = A[j,i] # factor for multiplying pivot row                A[j,0:] -= fac*A[i,0:]                A_inv[j,0:] -= fac*A_inv[i,0:]    return A rng2 = np.random.default_rng()N = rng2.integers(6,14)gen_num = rng2.integers(10,100000)A, x, b = rand_SPD_Axb(N, gen_num) # Random SPD problem generatorA_red = row_reduc(A)The random SPD coefficient matrix is:After passing it to the row_reduc function, we get:The diagonal elements of the matrix in row-echelon form are its pivots. A matrix is symmetric positive-definite if those pivots are positive non-zero values, as we’ve confirmed above. This gives us options with how we want to solve the system.Solution MethodsThere are a number of methods that can be applied to solving linear systems of equations with symmetric positive-definite coefficient matrices. We may classify these methods as iterative or direct. Iterative methods, like the Gauss-Seidel method we’ve already used, work by using successive solutions to get closer to the true solution. Apart from the Gauss-Seidel method, there is the similar Jacobi method as well as the more sophisticated Conjugate Gradient method. Direct methods solve the system Ax = b by finding the inverse of A and multiplying by the b matrix. Gaussian elimination, a variant of which is used in this post (the Gauss-Jordan method) is one method and Cholesky decomposition is another.The Jacobi method is like Gauss-Seidel but uses the the previous solution at each iteration. Dr. Zhiliang Xu from Notre Dame University presents a brief comparison of the two methods and discusses convergence rates.I recommend to the reader L. Ridgeway Scott’s discussion of the Conjugate Gradient method in their Numerical Analysis text [ref] (with Wikipedia for some orientation). Gross high-level simplification: imagine a space where the the true solution of a function Ax = b is separated from an initial conditon x_0. The conjugate gradient method finds a numerical solution close to the true solution by minimizing the distance between the numerical solution and the true solution (QA = xT Ax/2 - bTx). To minimize this distance, its gradient grad QA and the numerical residual Ax - b are used to find a direction and step size for for the numerical solution to be shifted. The Wikipedia page has a handy graphic showing this process geometrically and distinguishes the conjugate gradient from the gradient descent method (also seen in ML) by how the search directions differ: the conjugate gradient method changes each step’s search direction so that sequential search directions are orthogonal (or conjugate) to each other. These direction changes avoid repeating solutions or search directions.In mathematical notation, we consider the problem Cy=g and start with the residual as the search direction:Starting with our initial condition y0, we can calculate the initial residual r0 which is set to the initial search direction s0. Then, the iteration begins:In the above algorithm, all lower-case latin letters are column vectors and greek letters are scalars. With each iteration, the algorithm moves the numerical solution yk closer to the true solution by shifting it based on search directions sk, which itsef changes based on the residual and its previous iterations. The conjugate gradient method differs from other gradient descent methods by using search directions which are orthogonal to each other so that the solutions aren’t repeated.Direct solution methods basically solve the system Ax = b as x = A-1 b, which requires calculating the inverse. Gauss-Jordan elimination is a direct method where equations are reduced into a form that allows substituion. For example, in the pressure equation for Darcy’s law, the boundary conditions are given. Using Gauss-Jordan elimination, one would be able to reduce the system of equations to a form (see Upper Triangular form) where you may substitute the outlet pressure into an equation for the adjacent cell’s pressure. You may then solve for that cell’s pressure which will be used in the next cell’s equation.The Gauss-Jordan elimination algorithm included in the code presented here includes full-pivoting, basically conducting row operations to transform the original matrix A into an identity matrix I. By conducting the same row operations on the original matrix A and an identity matrix I, one can find the inverse of matrix A which can then be used as a linear operator with the source/constant vector b (x = A-1b). If the terms in A are constant over the time of a transient simulation, then this operation only needs to be done once, at the beginning, which saves computational time.Cholesky factorization is another direct method which divides the original coefficient matrix A into a lower triangular matrix and its conjugate transpose. It then conducts a two-step solution where an intermediate vector y is solved for with the lower triangular matrix L and the original source/constant vector b (Ly = b), then the desired vector x is solved for using the conjugate transpose L* and the intermediate vector (L*x = y). Wikipedia’s and NumPy’s/SciPy’s pages on the Cholesky factorization method vis-a-vis solving linear equations are useful sources for how it works.Solution CodeThe Gauss-Seidel method and Gauss-Jordan methods are constructed in Python below. The Gauss-Seidel method, as it was coded in the previous post, could only solve 1D systems of equations, where only adjacent cells interacted with each other. However, the method can solve any system of equations where the coefficient matrix is symmetric-positive-definite. The Gauss-Seidel method code is updated to:#New Gauss-Seidel Codedef gauss_seidel(A,N,b,x0,tol):    # Gauss-Seidel: x0 is the initial solution    # No inverse matrix to return, just iteration states    ## Initialize    x = x0    dif = np.matmul(A,x)-b    res = np.array([LA.norm(dif)],dtype=float)    # tol = 1E-8    iter = 0    max_iter = 1E5    # print('&gt; Gauss-Seidel Initial Residual: {}'.format(res[0]))    ## Iteration Loop    res_len = len(res)    while ((res[res_len-1] &gt; tol) &amp; (iter &lt; max_iter)):        iter += 1        for i in range(0,N): # Loop through equations            x_sum = b[i]            for j in range(0,N):                 if (i != j): x_sum -= A[i,j]*x[j]            x[i] = x_sum/A[i,i]        if ((iter % 10) == 0):            dif = np.matmul(A,x)-b            res_iter = np.array(LA.norm(dif))            res = np.append(res,res_iter) # check this code            res_len = len(res)        # print('&gt; Gauss-Seidel Residual at iter {}: {}'.format(iter,res_iter))    if (res[res_len-1] &lt;= tol):         print('&gt;&gt; Gauss-Seidel Converged at iteration',iter,\\            '! tol =',tol,', res =',res[res_len-1])    else:        print('&gt; Gauss-Seidel Divergence at iteration',iter,\\            '! tol =',tol,', res =',res[res_len-1])    print_sol('Gauss-Seidel_Sol',A,A,x,np.matmul(A,x),N)    return x, res[res_len-1], iterWe can test it with a random symmetric-positive-definite coefficient matrix A and random solution vector x. Multiplying A and x, we get the constant vector b:import numpy as np...def rand_SPD_Axb(N,gen_num):    # Random A, x, and corresponding generation for Ax = b problem    rng = np.random.default_rng(gen_num)    # A: symmetric positive definite    A_seed = rng.integers(low=-5, high=5, size=(N,N)).astype(np.float)    A_seed_T = np.transpose(A_seed)    A = (np.abs(A_seed) + np.abs(A_seed_T))*0.5    A += np.diag(np.ones(N)*N)    A_org = A    print('Determinant of A:',LA.det(A))    x = rng.integers(low=-N, high=N, size=N).astype(np.float)    b = np.matmul(A,x)    print_mat1('A_Org',A,N)    print_mat3('Original',A,np.eye(N),np.eye(N),b,N)        return A, x, b...rng2 = np.random.default_rng()N = rng2.integers(6,14)gen_num = rng2.integers(10,100000)A, x, b = rand_SPD_Axb(N, gen_num)\tIn the current case, the matrix A and vector b are:            We then run the Gauss-Seidel method for the system and check the L2-norm of the residual vector _r =             Ax-b             _:      &gt;&gt;&gt; xarray([-3.,  0.,  5.,  1.,  0.,  5.])&gt;&gt;&gt; x_gsarray([-3.00000000e+00,  1.35871561e-12,  5.00000000e+00,  1.00000000e+00,       -5.07416331e-13,  5.00000000e+00])&gt;&gt;&gt; LA.norm(np.matmul(A,x_gs)-b) 2.465053629363389e-12&gt;&gt;&gt; LA.norm(x_gs-x) 2.4648988254742506e-12The true and Gauss-Seidel numerical solutions look close, both by difference between the vectors and the L2-norm of hte difference between the solutions. Additionally, the residual is small enough where we can assume that the numerical solution has converged. We can check how the method is performs by looking at individual iterations:In the line legend, the letters after x are the iteration number. The solution, visually, is already very close after 10 iterations. In a real case, a closer solution can be reached by running the code longer, either by increasing the maximum number of iterations or lowering the tolerance (basically the residual required).Gauss-JordanThe Gauss-Jordan method is coded as:# Gauss-Jordan Codedef gauss_jordan(A,N,b):    # Custom Gauss-Jordan Elimination Algo    # Notes from 9/11-13 2021 (Math folder)    A_org = np.copy(A) # Original A (need for tests)    b_org = np.copy(b)    A_inv = np.eye(N) # A inverse initialized as identity matrix    P_gen = np.eye(N) # General Permutation matrix    P = np.eye(N) # Permutation matrix for this column pivot    # Reduce to upper tridiagonal coefficient matrix    for i in range(0, N-1):        # Find row of pivot element in column i        i_max = i        for j in range(i+1,N):          if (abs(A[i_max,i]) &lt; abs(A[j,i])): i_max = j        if (A[i_max,i] &lt; 0.0):            A[i_max,0:] = A[i_max,0:]*-1.0 # Switch signs            A_inv[i_max,0:] = A_inv[i_max,0:]*-1.0            b[i_max] = b[i_max]*-1.0        # Move pivot row so column is on diagonal        if (i_max != i): # Swap rows            P[i_max, i_max] = 0.0            P[i, i] = 0.0            P[i_max, i] = 1.0 # Move row i to row i_max            P[i, i_max] = 1.0 # Move row i_max to row i            A = np.matmul(P,A)            A_inv = np.matmul(P,A_inv)             b = np.matmul(P,b)            P_gen = np.matmul(P, P_gen) # !compt. intensive!        # Pivot        fac = A[i,i]        b[i] = b[i]/fac # A[i,i] is now pivot element        A_inv[i,0:] = A_inv[i,0:]/fac        A[i,0:] = A[i,0:]/fac # pivot element becomes 1        for j in range(i+1,N): # Other rows            if  (A[j,i] != 0.0): # skip rows with column element = 0                fac = A[j,i] # factor for multiplying pivot row                A[j,0:] -= fac*A[i,0:]                A_inv[j,0:] -= fac*A_inv[i,0:]                b[j] -= fac*b[i]    if (A[N-1,N-1] != 0.0):        fac = A[N-1,N-1]        b[N-1] = b[N-1]/fac # last row        A_inv[N-1,0:] = A_inv[N-1,0:]/fac        A[N-1,0:] = A[N-1,0:]/fac    elif (b[N-1] != 0.0): # No solution here        raise Exception('Singular matrix: 0*x_N != 0.0')        # Check: Matrix is in upper tridiagonal form    if (LA.norm(A-np.triu(A)) &lt;= 1.0E-14):        print('&gt;&gt; A reduced to upper tridiagonal matrix! &lt;&lt;')    else:         print('&gt; Partial Reduction Failed!')        return b, A        # Back sub for trailing terms (full pivoting)    for i in range(N-1,0,-1): # Start: bottom row cancels out other rows        for j in range(i-1,-1,-1): # Other rows            if (A[j,i] != 0.0):                fac = A[j,i]                A[j,0:] -= fac*A[i,0:]                A_inv[j,0:] -= fac*A_inv[i,0:]                b[j] -= fac*b[i]        # Revert solutions back to original order    P_trans = np.transpose(P)    A_inv_perm = np.matmul(P_trans,A_inv)       # Solution Test: norm(x - (A_inv x b)) &lt; some precision number    l2_res = LA.norm(b-np.matmul(A_inv,b_org))    # Check: Full pivoting has turned A into identity matrix    if (LA.norm(A-np.eye(N))&lt;1.0E-14):         return b, A_inv    else:        print('&gt; Full Pivoting Failed!')        return b, ASo we run it and check results and residual:&gt;&gt;&gt; xarray([-3.,  0.,  5.,  1.,  0.,  5.])&gt;&gt;&gt; x_gjarray([-3.00000000e+00, -4.44089210e-16,  5.00000000e+00,  1.00000000e+00,       -2.22044605e-16,  5.00000000e+00])&gt;&gt;&gt; LA.norm(np.matmul(A,x_gj)-b)  0.0&gt;&gt;&gt; LA.norm(x_gj-x)                    1.4895204919483639e-15            The Gauss-Jordan residual is zero and the L2-norm of the error vector, _             xgj             _ is on the order of 1E-15, which is orders of magnitude smaller than the Gauss-Seidel method. While the residuals are different, the solutions will appear to overlap.  For the purposes of this test, they are close enough. However, for a transient study, where a series of solutions will be stacked on top of each other, this residuals become important as the errors will accumulate.      So far, we’ve coded the schemes explicitly, which forces us to understand the schemes but also allows us to report more data from the solver, for example, how the solver behaves at intermediate solutions. This can be invaluable if we’re not sure whether our understanding of the problem is accurate. However, once we’re sure that we understand the mathematical problem and that the coefficient matrix is correct, we can use solvers already in the Python/NumPy/SciPy libraries to get the solution. The advantages, beyond not having to debug our own code, are the optimizations that the package’s developers have implemented. Though not having to debug is a huge advantage when solving small toy problems, the optimizations can be crucial when dealing with multi-billion calculation problems.We call the conjugate gradient method from Sparse Linear Algebra toolbox from SciPy and the Cholesky factorization method from SciPy’s Linear Algebra toolbox as:import scipy.sparse.linalg as SLAfrom scipy.linalg import cho_factor, cho_solve...[x_cg, info_cg] = cg(A, b)    c_cho, low = cho_factor(A)x_cho = cho_solve((c_cho, low), b)The results for the conjugate gradient method are:&gt;&gt;&gt; x_cgarray([-3.00000000e+00, -4.44089210e-16,  5.00000000e+00,  1.00000000e+00,       -2.22044605e-16,  5.00000000e+00])&gt;&gt;&gt; LA.norm(np.matmul(A,x_cg)-b)0.0&gt;&gt;&gt; LA.norm(x_cg-x)              1.4895204919483639e-15and, for the Cholesky factorization:&gt;&gt;&gt; x_choarray([-3.00000000e+00, -4.44089210e-16,  5.00000000e+00,  1.00000000e+00,       -2.22044605e-16,  5.00000000e+00])&gt;&gt;&gt; LA.norm(np.matmul(A,x_cho)-b)0.0&gt;&gt;&gt; LA.norm(x_cho-x)              1.4895204919483639e-15The results show about the same accuracy as the Gauss-Jordan method we coded, but without the having to code.Apply to Darcy's LawNow that we know our four methods work on the general class of problems (symmetric-positive-definite coefficient matrix), we can now apply them to our specific problem and see which one works best. We set up the terms for the pressures in the previous post. This post will leave it to the reader to put the right terms for the pressure equations from the previous post into the coefficient matrix at the beginning of this post. Just know, the problem has not changed, just the form. The python code may also be deciphered for clues as to the terms.We call methods on the coefficient matrices and constant vectors:import multi_solv_v3 as msimport darcy_v1 as dcimport scipy.sparse.linalg as SLAfrom scipy.linalg import cho_factor, cho_solveimport csvimport numpy as npfrom numpy import linalg as LAimport copyimport time# Read Casewith open('casefile_mesh.csv',newline='') as casefile:  # open and read case params    casereader = csv.DictReader(casefile)     i = 0     caselist = {}     for row in casereader:            caselist[i] = row         i += 1         for i in range(0,len(caselist)):      # Create case object and check values of variables      case_current = dc.case_param(caselist[i])      print(case_current.x0)      print(case_current.dx)      # Initialize and check mesh object creation ##      case_mesh = dc.mesh(case_current) # create case mesh from case parameters      Nx = case_mesh.Nx      print('Node Locations w/ inlet:', case_mesh.x[0:5]) # check inlet location and spacing      print('Nx:', case_mesh.Nx) # check number of elements      print('Outlet Location:', case_mesh.x[case_mesh.Nx-1])      print('Face Locations:', case_mesh.xc[0:5]) #       # Create fluid and porous medium objects for this specific case ##      fl1 = dc.fluid(case_mesh,case_current.fl) # fluid object, determined by mesh and case's fluid properties      pm1 = dc.por_med(case_mesh,case_current.pm) # porous medium object, determined by mesh and case's porous medium properties      # Linear P      print('Original P:',fl1.p[0:4],fl1.p[case_mesh.Nx-5:case_mesh.Nx-1])      fl1.p_lin(case_mesh)      print('Linear P:',fl1.p[0:4],fl1.p[case_mesh.Nx-5:case_mesh.Nx-1])      # Darcy Velocity      print('Original u:',fl1.u[0:4]) # velocity from initialization      fl1.u = np.zeros(case_mesh.Nx) # zero out velocity       fl1.darcyv(case_mesh,pm1) # use darcyv method      print('Darcy u:',fl1.u[0:4]) # print to confirm that darcyv did what it was supposed to (got same solution as initialization)      ## Pressure calculation using Different Solvers      # Gauss-Seidel Original      fl_gso = dc.fluid(case_mesh,case_current.fl)      print('Original P:',fl_gso.p[0:4],            fl_gso.p[Nx-5:Nx-1])      A,b = fl_gso.coeff_Ab(case_mesh,pm1)      time_gso = time.perf_counter()      [iter_gso, res_gso] = fl_gso.gauss_seidel(case_mesh,pm1,1.0E-9)      time_gso -= time.perf_counter()      time_gso = abs(time_gso)      fl_gso.darcyv(case_mesh,pm1)      # Gauss-Seidel      fl_gs = dc.fluid(case_mesh,case_current.fl)      # print('Original P:',fl_gs.p[0:4],      #       fl_gs.p[Nx-5:Nx-1])      A,b = fl_gs.coeff_Ab(case_mesh,pm1)      time_gs = time.perf_counter()      fl_gs.p, res_gs, iter_gs = ms.gauss_seidel(A,Nx,b,np.zeros(Nx),1.0E-9)      time_gs -= time.perf_counter()      time_gs = abs(time_gs)      fl_gs.darcyv(case_mesh,pm1)      # Gauss-Jordan      fl_gj = dc.fluid(case_mesh,case_current.fl)      time_gj = time.perf_counter()      fl_gj.p, res_gj = ms.gauss_jordan(A,Nx,b)      time_gj -= time.perf_counter()      time_gj = abs(time_gj)      fl_gj.darcyv(case_mesh,pm1)      # Conjugate Gradient      fl_cg = dc.fluid(case_mesh,case_current.fl)      time_cg = time.perf_counter()      fl_cg.p, info_cg = SLA.cg(A, b, tol=1.0E-9)      time_cg -= time.perf_counter()      time_cg = abs(time_cg)      fl_cg.darcyv(case_mesh,pm1)       # Conjugate Gradient Squared      fl_cgs = dc.fluid(case_mesh,case_current.fl)      time_cgs = time.perf_counter()      fl_cgs.p, info_cg = SLA.cgs(A, b, tol=1.0E-9)      time_cgs -= time.perf_counter()      time_cgs = abs(time_cgs)      fl_cgs.darcyv(case_mesh,pm1)       # Cholesky Factorization      fl_cho = dc.fluid(case_mesh,case_current.fl)      time_cho = time.perf_counter()      c_cho, low = cho_factor(A)      fl_cho.p = cho_solve((c_cho, low), b)      time_cho -= time.perf_counter()      time_cho = abs(time_cho)      fl_cho.darcyv(case_mesh,pm1)The L2-norms of the error vectors show how poor the Gauss-Seidel method compares against the other methods:&gt;&gt;&gt; LA.norm(fl_gs.p-fl1.p)0.01010884570852091&gt;&gt;&gt; LA.norm(fl_gj.p-fl1.p)  5.312732304408523e-12&gt;&gt;&gt; LA.norm(fl_cg.p-fl1.p)  5.312732304408523e-12&gt;&gt;&gt; LA.norm(fl_cho.p-fl1.p)  5.312732304408523e-12Apart from the Gauss-Seidel method, the methods have reasonably close residuals. What does this look like with regards to the pressure fields?They virtually overlap, despite the large difference in the error norms. So, apart from the error norm, how else would we distinguish the methods? Since our case is relatively simple, we can use two basic criteria: timing and memory usage. Both are important for very large problems, for example if we broke the domain into millions of node elements. In comparison, the tests we did earlier with the random symmetric-positive-definite coefficient matrix only used 6 elements. For this post, only time will be considered:Timing (s): G-Seidel | G-Jordan | Conj. Grad | Cholesky----------------------------------------------------------------79.4208762 | 0.0295643 | 0.0014511 | 0.0019525With 100 elements, it takes over a minute for the Gauss-Seidel method while the other methods take less than one second.So why would we use the Gauss-Seidel method? Using the method as coded in the previous post, with the equations coded directly (center, upstream, and downstream terms  rather than put into Ax = b form, the only values kept in memory were the pressure vector, permeability, and viscosity, a total of 3N terms. The other methods have a minimum of N2 values (assuming sparse matrices aren’t used). In the case that the domain is divided into millions of elements, it may only be possible to use the Gauss-Seidel method to solve the problem on a personal computer.",
            "content_html": "<p>We have equations for the pressure at every point within the 1D domain, but we’re using a basic method to solve the equations. Here’s some trivia: Gauss mentioned it first in 1823 but the method wasn’t published until Seidel wrote it up in 1874. Since then, many newer methods have been developed to solve linear systems of equations. This post will cover three more commonly used algorithms: Cholesky decomposition, Gauss-Jordan, and the conjugate gradient method.</p><h2 id=\"system-characterization\">System Characterization</h2><p>First, let’s consider our system of equations: to find the pressure, we solve only three unique sets of equations: the equations for the cells near the inlet and outlet and the equation for all the cells in the middle. Additionally, the cells’ pressures only depend on the adjacent pressures, of which two are given (inlet and outlet). Such a system can be described in matrix form Ax = b, where A is a coefficient matrix, x is a column vector representing the variables we want to find, and b is a column vector representing the constants in each equation:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?A&space;=&space;\\begin{bmatrix}1&space;&amp;&space;...&space;&amp;&space;...&space;&amp;&space;...&space;&amp;&space;...&space;&amp;&space;...&space;&amp;&space;0&space;\\\\A_{21}&space;&amp;&space;-&space;A_{21}-&space;A_{23}&space;&amp;&space;A_{23}&space;&amp;&space;...&space;&amp;&space;...&space;&amp;&space;...&space;&amp;&space;0&space;\\\\...&space;&amp;&space;A_{32}&space;&amp;&space;-A_{32}&space;-&space;A_{34}&space;&amp;&space;A_{34}&space;&amp;&space;...&space;&amp;&space;...&space;&amp;&space;0&space;\\\\...&space;&amp;&space;...&space;&amp;&space;...&space;&amp;&space;...&space;&amp;&space;...&space;&amp;&space;...&space;&amp;&space;...&space;\\\\...&space;&amp;&space;...&space;&amp;&space;A_{i,i-1}&space;&amp;&space;-A_{i,i-1}&space;-&space;A_{i,i&plus;1}&space;&amp;&space;A_{i,i&plus;1}&space;&amp;&space;...&space;&amp;&space;...&space;\\\\...&space;&amp;&space;...&space;&amp;&space;...&space;&amp;&space;...&space;&amp;&space;...&space;&amp;&space;...&space;&amp;&space;...&space;\\\\0&space;&amp;&space;&space;...&space;&amp;&space;...&space;&amp;&space;...&space;&amp;&space;...&space;&amp;&space;...&space;&amp;&space;1&space;\\\\\\end{bmatrix}\" title=\"A = \\begin{bmatrix}1 &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; 0 \\\\A_{21} &amp; - A_{21}- A_{23} &amp; A_{23} &amp; ... &amp; ... &amp; ... &amp; 0 \\\\... &amp; A_{32} &amp; -A_{32} - A_{34} &amp; A_{34} &amp; ... &amp; ... &amp; 0 \\\\... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... \\\\... &amp; ... &amp; A_{i,i-1} &amp; -A_{i,i-1} - A_{i,i+1} &amp; A_{i,i+1} &amp; ... &amp; ... \\\\... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... \\\\0 &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; 1 \\\\\\end{bmatrix}\" /></p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?x&space;=&space;\\begin{bmatrix}P_1&space;\\\\:&space;\\\\P_i&space;\\\\:&space;\\\\P_N\\end{bmatrix},&space;\\&space;b&space;=&space;\\begin{bmatrix}P_{inlet}&space;\\\\:&space;\\\\0&space;\\\\:&space;\\\\P_{outlet}\\end{bmatrix}&space;\" title=\"x = \\begin{bmatrix}P_1 \\\\: \\\\P_i \\\\: \\\\P_N\\end{bmatrix},&space;\\ b = \\begin{bmatrix}P_{inlet} \\\\: \\\\0 \\\\: \\\\P_{outlet}\\end{bmatrix} \" /></p><p>The inlet and outlet pressures are represented by the top and bottom rows of the matrix and both vectors, respectively. Because they have known pressures, they only have one value in the matrix and the given pressure in the b-vector. All other “internal” pressures depend on their neighboring pressures only. Therefore, their b-vector values are zero and they have three entries in their A-matrix (the left, center, and right cells).</p><p>One important feature of the matrix: it is symmetric. That is, that the coefficient matrix’s transpose is equal to the matrix itself. We can see this instantly by checking the entries on either side of the top left to bottom right diagonal. Additionally, the matrix is positive definite. This is not as obvious, unless you’ve had prior experience with such a matrix, but it can be checked by conducting Gaussian elimination to get the matrix into upper triangular/row echelon form. Let's get the row-echelon form using Python and NumPy:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>import numpy as npdef row_reduc(A_org):    N,M = A_org.shape    if (N != M): raise Exception('Matrix must be square! Size:',N,',',M)        # Setup    A = np.copy(A_org)    A_inv = np.eye(N) # A inverse initialized as identity matrix    P_gen = np.eye(N) # General Permutation matrix    P = np.eye(N) # Permutation matrix for this column pivot    # Reduce to upper tridiagonal coefficient matrix    for i in range(0, N-1):        # Find row of pivot element in column i        i_max = i        for j in range(i+1,N):          if (abs(A[i_max,i]) &lt; abs(A[j,i])): i_max = j        if (A[i_max,i] &lt; 0.0):            A[i_max,0:] = A[i_max,0:]*-1.0 # Switch signs            A_inv[i_max,0:] = A_inv[i_max,0:]*-1.0        # Move pivot row so column is on diagonal        if (i_max != i): # Swap rows            P[i_max, i_max] = 0.0            P[i, i] = 0.0            P[i_max, i] = 1.0 # Move row i to row i_max            P[i, i_max] = 1.0 # Move row i_max to row i            A = np.matmul(P,A)            A_inv = np.matmul(P,A_inv)             P_gen = np.matmul(P, P_gen) # !compt. intensive!        # Pivot        fac = A[i,i]        A_inv[i,0:] = A_inv[i,0:]/fac        A[i,0:] = A[i,0:]/fac # pivot element becomes 1        for j in range(i+1,N): # Other rows            if  (A[j,i] != 0.0): # skip rows with column element = 0                fac = A[j,i] # factor for multiplying pivot row                A[j,0:] -= fac*A[i,0:]                A_inv[j,0:] -= fac*A_inv[i,0:]    return A rng2 = np.random.default_rng()N = rng2.integers(6,14)gen_num = rng2.integers(10,100000)A, x, b = rand_SPD_Axb(N, gen_num) # Random SPD problem generatorA_red = row_reduc(A)</code></pre></div></div><p>The random SPD coefficient matrix is:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?A&space;=&space;\\begin{bmatrix}11&space;&space;&amp;&space;2&space;&space;&space;&amp;&space;3.5&space;&amp;&space;1.5&space;&amp;&space;3.5&space;&amp;&space;2&space;&space;&space;&amp;&space;3&space;&space;&space;\\\\2&space;&space;&space;&amp;&space;7&space;&space;&space;&amp;&space;0.5&space;&amp;&space;5&space;&space;&space;&amp;&space;2.5&space;&amp;&space;2&space;&space;&space;&amp;&space;2.5&space;\\\\3.5&space;&amp;&space;0.5&space;&amp;&space;10&space;&space;&amp;&space;2.5&space;&amp;&space;3&space;&space;&space;&amp;&space;4&space;&space;&space;&amp;&space;1&space;&space;&space;\\\\1.5&space;&amp;&space;5&space;&space;&space;&amp;&space;2.5&space;&amp;&space;8&space;&space;&space;&amp;&space;0.5&space;&amp;&space;2.5&space;&amp;&space;3.5&space;\\\\3.5&space;&amp;&space;2.5&space;&amp;&space;3&space;&space;&space;&amp;&space;0.5&space;&amp;&space;12&space;&space;&amp;&space;2&space;&space;&space;&amp;&space;2&space;&space;&space;\\\\2&space;&space;&space;&amp;&space;2&space;&space;&space;&amp;&space;4&space;&space;&space;&amp;&space;2.5&space;&amp;&space;2&space;&space;&space;&amp;&space;11&space;&space;&amp;&space;1&space;&space;&space;\\\\3&space;&space;&space;&amp;&space;2.5&space;&amp;&space;1&space;&space;&space;&amp;&space;3.5&space;&amp;&space;2&space;&space;&space;&amp;&space;1&space;&space;&space;&amp;&space;12&space;\\end{bmatrix}\" title=\"A = \\begin{bmatrix}11 &amp; 2 &amp; 3.5 &amp; 1.5 &amp; 3.5 &amp; 2 &amp; 3 \\\\2 &amp; 7 &amp; 0.5 &amp; 5 &amp; 2.5 &amp; 2 &amp; 2.5 \\\\3.5 &amp; 0.5 &amp; 10 &amp; 2.5 &amp; 3 &amp; 4 &amp; 1 \\\\1.5 &amp; 5 &amp; 2.5 &amp; 8 &amp; 0.5 &amp; 2.5 &amp; 3.5 \\\\3.5 &amp; 2.5 &amp; 3 &amp; 0.5 &amp; 12 &amp; 2 &amp; 2 \\\\2 &amp; 2 &amp; 4 &amp; 2.5 &amp; 2 &amp; 11 &amp; 1 \\\\3 &amp; 2.5 &amp; 1 &amp; 3.5 &amp; 2 &amp; 1 &amp; 12 \\end{bmatrix}\" /></p><p>After passing it to the row_reduc function, we get:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?A&space;=&space;\\begin{bmatrix}1&space;&amp;&space;0.181818&space;&amp;&space;0.318182&space;&amp;&space;0.136364&space;&amp;&space;0.318182&space;&amp;&space;0.181818&space;&amp;&space;0.272727&space;\\\\0&space;&amp;&space;1&space;&space;&space;&space;&space;&space;&space;&space;&amp;&space;-0.02055&space;&amp;&space;0.712329&space;&amp;&space;0.280822&space;&amp;&space;0.246575&space;&amp;&space;0.294521&space;\\\\0&space;&amp;&space;0&space;&space;&space;&space;&space;&space;&space;&space;&amp;&space;1&space;&space;&space;&space;&space;&space;&space;&space;&amp;&space;0.238628&space;&amp;&space;0.216654&space;&amp;&space;0.382421&space;&amp;&space;0.009638&space;\\\\0&space;&amp;&space;0&space;&space;&space;&space;&space;&space;&space;&space;&amp;&space;0&space;&space;&space;&space;&space;&space;&space;&space;&amp;&space;1&space;&space;&space;&space;&space;&space;&space;&space;&amp;&space;-0.44976&space;&amp;&space;0.063985&space;&amp;&space;0.427869&space;\\\\0&space;&amp;&space;0&space;&space;&space;&space;&space;&space;&space;&space;&amp;&space;0&space;&space;&space;&space;&space;&space;&space;&space;&amp;&space;0&space;&space;&space;&space;&space;&space;&space;&space;&amp;&space;1&space;&space;&space;&space;&space;&space;&space;&space;&amp;&space;0.030697&space;&amp;&space;0.134696&space;\\\\0&space;&amp;&space;0&space;&space;&space;&space;&space;&space;&space;&space;&amp;&space;0&space;&space;&space;&space;&space;&space;&space;&space;&amp;&space;0&space;&space;&space;&space;&space;&space;&space;&space;&amp;&space;0&space;&space;&space;&space;&space;&space;&space;&space;&amp;&space;1&space;&space;&space;&space;&space;&space;&space;&space;&amp;&space;-0.02305&space;\\\\0&space;&amp;&space;0&space;&space;&space;&space;&space;&space;&space;&space;&amp;&space;0&space;&space;&space;&space;&space;&space;&space;&space;&amp;&space;0&space;&space;&space;&space;&space;&space;&space;&space;&amp;&space;0&space;&space;&space;&space;&space;&space;&space;&space;&amp;&space;0&space;&space;&space;&space;&space;&space;&space;&space;&amp;&space;9.7165&space;&space;\\end{bmatrix}\" title=\"A = \\begin{bmatrix}1 &amp; 0.181818 &amp; 0.318182 &amp; 0.136364 &amp; 0.318182 &amp; 0.181818 &amp; 0.272727 \\\\0 &amp; 1 &amp; -0.02055 &amp; 0.712329 &amp; 0.280822 &amp; 0.246575 &amp; 0.294521 \\\\0 &amp; 0 &amp; 1 &amp; 0.238628 &amp; 0.216654 &amp; 0.382421 &amp; 0.009638 \\\\0 &amp; 0 &amp; 0 &amp; 1 &amp; -0.44976 &amp; 0.063985 &amp; 0.427869 \\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0.030697 &amp; 0.134696 \\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; -0.02305 \\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}\" /></p><p>The diagonal elements of the matrix in row-echelon form are its pivots. A matrix is symmetric positive-definite if those pivots are positive non-zero values, as we’ve confirmed above. This gives us options with how we want to solve the system.</p><h2 id=\"solution-methods\">Solution Methods</h2><p>There are a number of methods that can be applied to solving linear systems of equations with symmetric positive-definite coefficient matrices. We may classify these methods as iterative or direct. Iterative methods, like the Gauss-Seidel method we’ve already used, work by using successive solutions to get closer to the true solution. Apart from the Gauss-Seidel method, there is the similar Jacobi method as well as the more sophisticated Conjugate Gradient method. Direct methods solve the system Ax = b by finding the inverse of A and multiplying by the b matrix. Gaussian elimination, a variant of which is used in this post (the Gauss-Jordan method) is one method and Cholesky decomposition is another.</p><p>The Jacobi method is like Gauss-Seidel but uses the the previous solution at each iteration. Dr. Zhiliang Xu from Notre Dame University presents a <a href=\"https://www3.nd.edu/~zxu2/acms40390F12/Lec-7.3.pdf\">brief comparison</a> of the two methods and discusses convergence rates.</p><p>I recommend to the reader L. Ridgeway Scott’s discussion of the Conjugate Gradient method in their Numerical Analysis text [ref] (with Wikipedia for some orientation). Gross high-level simplification: imagine a space where the the true solution of a function Ax = b is separated from an initial conditon x_0. The conjugate gradient method finds a numerical solution close to the true solution by minimizing the distance between the numerical solution and the true solution (<em>Q<sub>A</sub> = x<sup>T</sup> Ax/2 - b<sup>T</sup>x</em>). To minimize this distance, its gradient <em>grad Q<sub>A</sub></em> and the numerical residual <em>Ax - b</em> are used to find a direction and step size for for the numerical solution to be shifted. The <a href=\"https://en.wikipedia.org/wiki/Conjugate_gradient_method\">Wikipedia page</a> has a handy graphic showing this process geometrically and distinguishes the conjugate gradient from the gradient descent method (also seen in ML) by how the search directions differ: the conjugate gradient method changes each step’s search direction so that sequential search directions are orthogonal (or conjugate) to each other. These direction changes avoid repeating solutions or search directions.</p><p>In mathematical notation, we consider the problem <em>Cy=g</em> and start with the residual as the search direction:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?\\begin{align*}Cy&space;&amp;=&space;g&space;\\\\&space;s_0&space;=&space;r_0&space;&amp;=&space;Cy_0-g\\end{align*}\" /></p><p>Starting with our initial condition <em>y<sub>0</sub></em>, we can calculate the initial residual <em>r<sub>0</sub></em> which is set to the initial search direction <em>s<sub>0</sub></em>. Then, the iteration begins:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?\\begin{align*}for\\;\\;k &amp;= 0,1,2,...:\\\\ &amp;\\alpha_k =-\\dfrac{(r_k,s_k)_I}{(s_k,z_k)_I},\\;\\; (r_k,s_k)_I = r_k^T s_k\\\\&amp;y_{k+1} = y_k + \\alpha_k s_k,\\;\\; z_k=Cs_k\\\\ &amp;r_{k+1} = Cy_{k+1}-g=r_k+\\alpha_kCs_k=r_k+\\alpha_kz_k\\\\ &amp;\\beta_k = -\\dfrac{(r_{k+1},z_k)_I}{(s_k,z_k)_I}\\\\ &amp;s_{k+1} = r_{k+1} + \\beta_k s_k \\end{align*} \" /></p><p>In the above algorithm, all lower-case latin letters are column vectors and greek letters are scalars. With each iteration, the algorithm moves the numerical solution <em>y<sub>k</sub></em> closer to the true solution by shifting it based on search directions <em>s<sub>k</sub></em>, which itsef changes based on the residual and its previous iterations. The conjugate gradient method differs from other gradient descent methods by using search directions which are orthogonal to each other so that the solutions aren’t repeated.</p><p>Direct solution methods basically solve the system <em>Ax = b</em> as <em>x = A<sup>-1</sup> b</em>, which requires calculating the inverse. Gauss-Jordan elimination is a direct method where equations are reduced into a form that allows substituion. For example, in the pressure equation for Darcy’s law, the boundary conditions are given. Using Gauss-Jordan elimination, one would be able to reduce the system of equations to a form (see Upper Triangular form) where you may substitute the outlet pressure into an equation for the adjacent cell’s pressure. You may then solve for that cell’s pressure which will be used in the next cell’s equation.</p><p>The Gauss-Jordan elimination algorithm included in the code presented here includes full-pivoting, basically conducting row operations to transform the original matrix A into an identity matrix I. By conducting the same row operations on the original matrix A and an identity matrix I, one can find the inverse of matrix A which can then be used as a linear operator with the source/constant vector b (<em>x = A<sup>-1</sup>b</em>). If the terms in A are constant over the time of a transient simulation, then this operation only needs to be done once, at the beginning, which saves computational time.</p><p>Cholesky factorization is another direct method which divides the original coefficient matrix A into a lower triangular matrix and its conjugate transpose. It then conducts a two-step solution where an intermediate vector <em>y</em> is solved for with the lower triangular matrix <em>L</em> and the original source/constant vector <em>b</em> (<em>Ly = b</em>), then the desired vector x is solved for using the conjugate transpose <em>L<sup>*</sup></em> and the intermediate vector (<em>L<sup>*</sup>x = y</em>). Wikipedia’s and NumPy’s/SciPy’s pages on the Cholesky factorization method vis-a-vis solving linear equations are useful sources for how it works.</p><h2 id=\"solution-code\">Solution Code</h2><p>The Gauss-Seidel method and Gauss-Jordan methods are constructed in Python below. The Gauss-Seidel method, as it was coded in the previous post, could only solve 1D systems of equations, where only adjacent cells interacted with each other. However, the method can solve any system of equations where the coefficient matrix is symmetric-positive-definite. The Gauss-Seidel method code is updated to:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>#New Gauss-Seidel Codedef gauss_seidel(A,N,b,x0,tol):    # Gauss-Seidel: x0 is the initial solution    # No inverse matrix to return, just iteration states    ## Initialize    x = x0    dif = np.matmul(A,x)-b    res = np.array([LA.norm(dif)],dtype=float)    # tol = 1E-8    iter = 0    max_iter = 1E5    # print('&gt; Gauss-Seidel Initial Residual: {}'.format(res[0]))    ## Iteration Loop    res_len = len(res)    while ((res[res_len-1] &gt; tol) &amp; (iter &lt; max_iter)):        iter += 1        for i in range(0,N): # Loop through equations            x_sum = b[i]            for j in range(0,N):                 if (i != j): x_sum -= A[i,j]*x[j]            x[i] = x_sum/A[i,i]        if ((iter % 10) == 0):            dif = np.matmul(A,x)-b            res_iter = np.array(LA.norm(dif))            res = np.append(res,res_iter) # check this code            res_len = len(res)        # print('&gt; Gauss-Seidel Residual at iter {}: {}'.format(iter,res_iter))    if (res[res_len-1] &lt;= tol):         print('&gt;&gt; Gauss-Seidel Converged at iteration',iter,\\            '! tol =',tol,', res =',res[res_len-1])    else:        print('&gt; Gauss-Seidel Divergence at iteration',iter,\\            '! tol =',tol,', res =',res[res_len-1])    print_sol('Gauss-Seidel_Sol',A,A,x,np.matmul(A,x),N)    return x, res[res_len-1], iter</code></pre></div></div><p>We can test it with a random symmetric-positive-definite coefficient matrix <em>A</em> and random solution vector <em>x</em>. Multiplying <em>A</em> and <em>x</em>, we get the constant vector <em>b</em>:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>import numpy as np...def rand_SPD_Axb(N,gen_num):    # Random A, x, and corresponding generation for Ax = b problem    rng = np.random.default_rng(gen_num)    # A: symmetric positive definite    A_seed = rng.integers(low=-5, high=5, size=(N,N)).astype(np.float)    A_seed_T = np.transpose(A_seed)    A = (np.abs(A_seed) + np.abs(A_seed_T))*0.5    A += np.diag(np.ones(N)*N)    A_org = A    print('Determinant of A:',LA.det(A))    x = rng.integers(low=-N, high=N, size=N).astype(np.float)    b = np.matmul(A,x)    print_mat1('A_Org',A,N)    print_mat3('Original',A,np.eye(N),np.eye(N),b,N)        return A, x, b...rng2 = np.random.default_rng()N = rng2.integers(6,14)gen_num = rng2.integers(10,100000)A, x, b = rand_SPD_Axb(N, gen_num)\t</code></pre></div></div><p>In the current case, the matrix <em>A</em> and vector <em>b</em> are:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?A&space;=&space;\\begin{bmatrix}10&space;&space;&amp;&space;3&space;&space;&space;&amp;&space;1.5&space;&amp;&space;1.5&space;&amp;&space;1.5&space;&amp;&space;2.5&space;\\\\3&space;&space;&space;&amp;&space;9&space;&space;&space;&amp;&space;3&space;&space;&space;&amp;&space;1.5&space;&amp;&space;2.5&space;&amp;&space;4.5&space;\\\\1.5&space;&amp;&space;3&space;&space;&space;&amp;&space;6&space;&space;&space;&amp;&space;3&space;&space;&space;&amp;&space;2&space;&space;&space;&amp;&space;3&space;&space;&space;\\\\1.5&space;&amp;&space;1.5&space;&amp;&space;3&space;&space;&space;&amp;&space;7&space;&space;&space;&amp;&space;3.5&space;&amp;&space;3.5&space;\\\\1.5&space;&amp;&space;2.5&space;&amp;&space;2&space;&space;&space;&amp;&space;3.5&space;&amp;&space;10&space;&space;&amp;&space;0.5&space;\\\\2.5&space;&amp;&space;4.5&space;&amp;&space;3&space;&space;&space;&amp;&space;3.5&space;&amp;&space;0.5&space;&amp;&space;10&space;\\end{bmatrix},\\;\\;&space;b&space;=&space;\\begin{bmatrix}-8.5&space;\\\\30&space;\\\\43.5&space;\\\\35&space;\\\\\\11.5&space;\\\\\\61&space;\\end{bmatrix}\" title=\"A = \\begin{bmatrix}10 &amp; 3 &amp; 1.5 &amp; 1.5 &amp; 1.5 &amp; 2.5 \\\\3 &amp; 9 &amp; 3 &amp; 1.5 &amp; 2.5 &amp; 4.5 \\\\1.5 &amp; 3 &amp; 6 &amp; 3 &amp; 2 &amp; 3 \\\\1.5 &amp; 1.5 &amp; 3 &amp; 7 &amp; 3.5 &amp; 3.5 \\\\1.5 &amp; 2.5 &amp; 2 &amp; 3.5 &amp; 10 &amp; 0.5 \\\\2.5 &amp; 4.5 &amp; 3 &amp; 3.5 &amp; 0.5 &amp; 10 \\end{bmatrix},\\;\\; b = \\begin{bmatrix}-8.5 \\\\30 \\\\43.5 \\\\35 \\\\\\11.5 \\\\\\61 \\end{bmatrix}\" /></p><table>  <tbody>    <tr>      <td>We then run the Gauss-Seidel method for the system and check the L2-norm of the residual vector _r =</td>      <td> </td>      <td>Ax-b</td>      <td> </td>      <td>_:</td>    </tr>  </tbody></table><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt;&gt;&gt; xarray([-3.,  0.,  5.,  1.,  0.,  5.])&gt;&gt;&gt; x_gsarray([-3.00000000e+00,  1.35871561e-12,  5.00000000e+00,  1.00000000e+00,       -5.07416331e-13,  5.00000000e+00])&gt;&gt;&gt; LA.norm(np.matmul(A,x_gs)-b) 2.465053629363389e-12&gt;&gt;&gt; LA.norm(x_gs-x) 2.4648988254742506e-12</code></pre></div></div><p>The true and Gauss-Seidel numerical solutions look close, both by difference between the vectors and the L2-norm of hte difference between the solutions. Additionally, the residual is small enough where we can assume that the numerical solution has converged. We can check how the method is performs by looking at individual iterations:</p><p><img src=\"../../../assets/images/GS_Iter_Out.png\" alt=\"Gauss-Seidel Iterations\" title=\"Gauss-Seidel Iterations\" /></p><p>In the line legend, the letters after <em>x</em> are the iteration number. The solution, visually, is already very close after 10 iterations. In a real case, a closer solution can be reached by running the code longer, either by increasing the maximum number of iterations or lowering the tolerance (basically the residual required).</p><h3 id=\"gauss-jordan\">Gauss-Jordan</h3><p>The Gauss-Jordan method is coded as:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># Gauss-Jordan Codedef gauss_jordan(A,N,b):    # Custom Gauss-Jordan Elimination Algo    # Notes from 9/11-13 2021 (Math folder)    A_org = np.copy(A) # Original A (need for tests)    b_org = np.copy(b)    A_inv = np.eye(N) # A inverse initialized as identity matrix    P_gen = np.eye(N) # General Permutation matrix    P = np.eye(N) # Permutation matrix for this column pivot    # Reduce to upper tridiagonal coefficient matrix    for i in range(0, N-1):        # Find row of pivot element in column i        i_max = i        for j in range(i+1,N):          if (abs(A[i_max,i]) &lt; abs(A[j,i])): i_max = j        if (A[i_max,i] &lt; 0.0):            A[i_max,0:] = A[i_max,0:]*-1.0 # Switch signs            A_inv[i_max,0:] = A_inv[i_max,0:]*-1.0            b[i_max] = b[i_max]*-1.0        # Move pivot row so column is on diagonal        if (i_max != i): # Swap rows            P[i_max, i_max] = 0.0            P[i, i] = 0.0            P[i_max, i] = 1.0 # Move row i to row i_max            P[i, i_max] = 1.0 # Move row i_max to row i            A = np.matmul(P,A)            A_inv = np.matmul(P,A_inv)             b = np.matmul(P,b)            P_gen = np.matmul(P, P_gen) # !compt. intensive!        # Pivot        fac = A[i,i]        b[i] = b[i]/fac # A[i,i] is now pivot element        A_inv[i,0:] = A_inv[i,0:]/fac        A[i,0:] = A[i,0:]/fac # pivot element becomes 1        for j in range(i+1,N): # Other rows            if  (A[j,i] != 0.0): # skip rows with column element = 0                fac = A[j,i] # factor for multiplying pivot row                A[j,0:] -= fac*A[i,0:]                A_inv[j,0:] -= fac*A_inv[i,0:]                b[j] -= fac*b[i]    if (A[N-1,N-1] != 0.0):        fac = A[N-1,N-1]        b[N-1] = b[N-1]/fac # last row        A_inv[N-1,0:] = A_inv[N-1,0:]/fac        A[N-1,0:] = A[N-1,0:]/fac    elif (b[N-1] != 0.0): # No solution here        raise Exception('Singular matrix: 0*x_N != 0.0')        # Check: Matrix is in upper tridiagonal form    if (LA.norm(A-np.triu(A)) &lt;= 1.0E-14):        print('&gt;&gt; A reduced to upper tridiagonal matrix! &lt;&lt;')    else:         print('&gt; Partial Reduction Failed!')        return b, A        # Back sub for trailing terms (full pivoting)    for i in range(N-1,0,-1): # Start: bottom row cancels out other rows        for j in range(i-1,-1,-1): # Other rows            if (A[j,i] != 0.0):                fac = A[j,i]                A[j,0:] -= fac*A[i,0:]                A_inv[j,0:] -= fac*A_inv[i,0:]                b[j] -= fac*b[i]        # Revert solutions back to original order    P_trans = np.transpose(P)    A_inv_perm = np.matmul(P_trans,A_inv)       # Solution Test: norm(x - (A_inv x b)) &lt; some precision number    l2_res = LA.norm(b-np.matmul(A_inv,b_org))    # Check: Full pivoting has turned A into identity matrix    if (LA.norm(A-np.eye(N))&lt;1.0E-14):         return b, A_inv    else:        print('&gt; Full Pivoting Failed!')        return b, A</code></pre></div></div><p>So we run it and check results and residual:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt;&gt;&gt; xarray([-3.,  0.,  5.,  1.,  0.,  5.])&gt;&gt;&gt; x_gjarray([-3.00000000e+00, -4.44089210e-16,  5.00000000e+00,  1.00000000e+00,       -2.22044605e-16,  5.00000000e+00])&gt;&gt;&gt; LA.norm(np.matmul(A,x_gj)-b)  0.0&gt;&gt;&gt; LA.norm(x_gj-x)                    1.4895204919483639e-15</code></pre></div></div><table>  <tbody>    <tr>      <td>The Gauss-Jordan residual is zero and the L2-norm of the error vector, _</td>      <td> </td>      <td>x<sub>gj<sub></sub></sub></td>      <td> </td>      <td>_ is on the order of <em>1E-15</em>, which is orders of magnitude smaller than the Gauss-Seidel method. While the residuals are different, the solutions will appear to overlap.  For the purposes of this test, they are close enough. However, for a transient study, where a series of solutions will be stacked on top of each other, this residuals become important as the errors will accumulate.</td>    </tr>  </tbody></table><p>So far, we’ve coded the schemes explicitly, which forces us to understand the schemes but also allows us to report more data from the solver, for example, how the solver behaves at intermediate solutions. This can be invaluable if we’re not sure whether our understanding of the problem is accurate. However, once we’re sure that we understand the mathematical problem and that the coefficient matrix is correct, we can use solvers already in the Python/NumPy/SciPy libraries to get the solution. The advantages, beyond not having to debug our own code, are the optimizations that the package’s developers have implemented. Though not having to debug is a huge advantage when solving small toy problems, the optimizations can be crucial when dealing with multi-billion calculation problems.</p><p>We call the conjugate gradient method from Sparse Linear Algebra toolbox from SciPy and the Cholesky factorization method from SciPy’s Linear Algebra toolbox as:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>import scipy.sparse.linalg as SLAfrom scipy.linalg import cho_factor, cho_solve...[x_cg, info_cg] = cg(A, b)    c_cho, low = cho_factor(A)x_cho = cho_solve((c_cho, low), b)</code></pre></div></div><p>The results for the conjugate gradient method are:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt;&gt;&gt; x_cgarray([-3.00000000e+00, -4.44089210e-16,  5.00000000e+00,  1.00000000e+00,       -2.22044605e-16,  5.00000000e+00])&gt;&gt;&gt; LA.norm(np.matmul(A,x_cg)-b)0.0&gt;&gt;&gt; LA.norm(x_cg-x)              1.4895204919483639e-15</code></pre></div></div><p>and, for the Cholesky factorization:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt;&gt;&gt; x_choarray([-3.00000000e+00, -4.44089210e-16,  5.00000000e+00,  1.00000000e+00,       -2.22044605e-16,  5.00000000e+00])&gt;&gt;&gt; LA.norm(np.matmul(A,x_cho)-b)0.0&gt;&gt;&gt; LA.norm(x_cho-x)              1.4895204919483639e-15</code></pre></div></div><p>The results show about the same accuracy as the Gauss-Jordan method we coded, but without the having to code.</p><h2 id=\"apply-to-darcys-law\">Apply to Darcy's Law</h2><p>Now that we know our four methods work on the general class of problems (symmetric-positive-definite coefficient matrix), we can now apply them to our specific problem and see which one works best. We set up the terms for the pressures in the <a href=\"https://tim-munuhe.github.io/2021/06/07/solve-1d-darcy-continuity\">previous post</a>. This post will leave it to the reader to put the right terms for the pressure equations from the previous post into the coefficient matrix at the beginning of this post. Just know, the problem has not changed, just the form. The python code may also be deciphered for clues as to the terms.</p><p>We call methods on the coefficient matrices and constant vectors:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>import multi_solv_v3 as msimport darcy_v1 as dcimport scipy.sparse.linalg as SLAfrom scipy.linalg import cho_factor, cho_solveimport csvimport numpy as npfrom numpy import linalg as LAimport copyimport time# Read Casewith open('casefile_mesh.csv',newline='') as casefile:  # open and read case params    casereader = csv.DictReader(casefile)     i = 0     caselist = {}     for row in casereader:            caselist[i] = row         i += 1         for i in range(0,len(caselist)):      # Create case object and check values of variables      case_current = dc.case_param(caselist[i])      print(case_current.x0)      print(case_current.dx)      # Initialize and check mesh object creation ##      case_mesh = dc.mesh(case_current) # create case mesh from case parameters      Nx = case_mesh.Nx      print('Node Locations w/ inlet:', case_mesh.x[0:5]) # check inlet location and spacing      print('Nx:', case_mesh.Nx) # check number of elements      print('Outlet Location:', case_mesh.x[case_mesh.Nx-1])      print('Face Locations:', case_mesh.xc[0:5]) #       # Create fluid and porous medium objects for this specific case ##      fl1 = dc.fluid(case_mesh,case_current.fl) # fluid object, determined by mesh and case's fluid properties      pm1 = dc.por_med(case_mesh,case_current.pm) # porous medium object, determined by mesh and case's porous medium properties      # Linear P      print('Original P:',fl1.p[0:4],fl1.p[case_mesh.Nx-5:case_mesh.Nx-1])      fl1.p_lin(case_mesh)      print('Linear P:',fl1.p[0:4],fl1.p[case_mesh.Nx-5:case_mesh.Nx-1])      # Darcy Velocity      print('Original u:',fl1.u[0:4]) # velocity from initialization      fl1.u = np.zeros(case_mesh.Nx) # zero out velocity       fl1.darcyv(case_mesh,pm1) # use darcyv method      print('Darcy u:',fl1.u[0:4]) # print to confirm that darcyv did what it was supposed to (got same solution as initialization)      ## Pressure calculation using Different Solvers      # Gauss-Seidel Original      fl_gso = dc.fluid(case_mesh,case_current.fl)      print('Original P:',fl_gso.p[0:4],            fl_gso.p[Nx-5:Nx-1])      A,b = fl_gso.coeff_Ab(case_mesh,pm1)      time_gso = time.perf_counter()      [iter_gso, res_gso] = fl_gso.gauss_seidel(case_mesh,pm1,1.0E-9)      time_gso -= time.perf_counter()      time_gso = abs(time_gso)      fl_gso.darcyv(case_mesh,pm1)      # Gauss-Seidel      fl_gs = dc.fluid(case_mesh,case_current.fl)      # print('Original P:',fl_gs.p[0:4],      #       fl_gs.p[Nx-5:Nx-1])      A,b = fl_gs.coeff_Ab(case_mesh,pm1)      time_gs = time.perf_counter()      fl_gs.p, res_gs, iter_gs = ms.gauss_seidel(A,Nx,b,np.zeros(Nx),1.0E-9)      time_gs -= time.perf_counter()      time_gs = abs(time_gs)      fl_gs.darcyv(case_mesh,pm1)      # Gauss-Jordan      fl_gj = dc.fluid(case_mesh,case_current.fl)      time_gj = time.perf_counter()      fl_gj.p, res_gj = ms.gauss_jordan(A,Nx,b)      time_gj -= time.perf_counter()      time_gj = abs(time_gj)      fl_gj.darcyv(case_mesh,pm1)      # Conjugate Gradient      fl_cg = dc.fluid(case_mesh,case_current.fl)      time_cg = time.perf_counter()      fl_cg.p, info_cg = SLA.cg(A, b, tol=1.0E-9)      time_cg -= time.perf_counter()      time_cg = abs(time_cg)      fl_cg.darcyv(case_mesh,pm1)       # Conjugate Gradient Squared      fl_cgs = dc.fluid(case_mesh,case_current.fl)      time_cgs = time.perf_counter()      fl_cgs.p, info_cg = SLA.cgs(A, b, tol=1.0E-9)      time_cgs -= time.perf_counter()      time_cgs = abs(time_cgs)      fl_cgs.darcyv(case_mesh,pm1)       # Cholesky Factorization      fl_cho = dc.fluid(case_mesh,case_current.fl)      time_cho = time.perf_counter()      c_cho, low = cho_factor(A)      fl_cho.p = cho_solve((c_cho, low), b)      time_cho -= time.perf_counter()      time_cho = abs(time_cho)      fl_cho.darcyv(case_mesh,pm1)</code></pre></div></div><p>The L2-norms of the error vectors show how poor the Gauss-Seidel method compares against the other methods:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt;&gt;&gt; LA.norm(fl_gs.p-fl1.p)0.01010884570852091&gt;&gt;&gt; LA.norm(fl_gj.p-fl1.p)  5.312732304408523e-12&gt;&gt;&gt; LA.norm(fl_cg.p-fl1.p)  5.312732304408523e-12&gt;&gt;&gt; LA.norm(fl_cho.p-fl1.p)  5.312732304408523e-12</code></pre></div></div><p>Apart from the Gauss-Seidel method, the methods have reasonably close residuals. What does this look like with regards to the pressure fields?</p><p><img src=\"../../../assets/images/p_N100.png\" alt=\"P vs. x for different methods.\" title=\"P vs. x for different methods.\" /></p><p>They virtually overlap, despite the large difference in the error norms. So, apart from the error norm, how else would we distinguish the methods? Since our case is relatively simple, we can use two basic criteria: timing and memory usage. Both are important for very large problems, for example if we broke the domain into millions of node elements. In comparison, the tests we did earlier with the random symmetric-positive-definite coefficient matrix only used 6 elements. For this post, only time will be considered:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Timing (s): G-Seidel | G-Jordan | Conj. Grad | Cholesky----------------------------------------------------------------79.4208762 | 0.0295643 | 0.0014511 | 0.0019525</code></pre></div></div><p>With <em>100</em> elements, it takes over a minute for the Gauss-Seidel method while the other methods take less than one second.</p><p>So why would we use the Gauss-Seidel method? Using the method as coded in the previous post, with the equations coded directly (center, upstream, and downstream terms  rather than put into <em>Ax = b</em> form, the only values kept in memory were the pressure vector, permeability, and viscosity, a total of <em>3N</em> terms. The other methods have a minimum of <em>N<sup>2</sup></em> values (assuming sparse matrices aren’t used). In the case that the domain is divided into millions of elements, it may only be possible to use the Gauss-Seidel method to solve the problem on a personal computer.</p>",
            "url": "tim-munuhe.github.io/2021/11/21/apply-solvers",
            
            
            
            
            
            "date_published": "2021-11-21T00:00:00-05:00",
            "date_modified": "2021-11-21T00:00:00-05:00",
            
                "author":  {
                "name": "Timothy W. Munuhe, Ph.D.",
                "url": "tim-munuhe.gitub.io",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "tim-munuhe.github.io/2021/06/07/solve-1d-darcy-continuity",
            "title": "Basic Python with Darcy's Law - Solving Darcy's Law and Continuity Equation on 1D Mesh",
            "summary": "Create methods to solve for the pressure and velocity in a 1D saturated porous medium using Darcy's Law and the continuity equation",
            "content_text": "While the code we've developed so far allows us to go from parameters to plots in a few lines (assuming that all the classes and their methods are coded), the code also makes the assumption that the pressure is linear, which may not be true. To add more functionality to the code, let's figure out how to solve for the pressure distribution and velocity given only the parameters of the porous medium and the inlet and outlet conditions.MathIf the pressure is also unknown, then we need another equation to solve for pressure. So far, we've only used Darcy's Law. However, the assumptions of Darcy's law (slow flow through a porous medium) allow us to use another equation that accounts for mass conservation: the incompressible continuity equation:Since our case is 1D, we can simplify this to:This means that the velocity in the pipe is constant in the x-direction, which we knew before. What we want to find is the pressure distribution so we need to plug in Darcy's law into the simplified equation above:Our method from last week does not assume that the porous medium/liquid properties are constant so we'll keep the permeability and viscosity inside the parentheses. However, we can guess what the pressure distribution would be if we did. For now, let's move on to the equations that will be solved in Python.In the previous post, the velocity at the faces between the pressure points was coded but only briefly discussed. Let's flesh out the idea a bit more fully:The mesh consists of individual cells that meet at their left and right faces, as in the figure below:The middle cell experiences flow inwards from the left and outwards to the right. The adjacent cells have their own properties (K and mu specifically) so the pressure gradients within the cells may be different even though they have the same flow velocity (Darcy's Law). However, you also know that the pressure at the face is equal for both cell, so at face i+0.5:We don't know the pressure at the face so we need to remove it so that we have an equivalent permeability/viscosity factor that accounts for both cells. Luckily, we know K and mu in both cells so we can do some algebra to get the velocity across the face in terms of the adjacent cell pressures:This expression will take care of all interior faces.I wrote at the beginning that the continuity equation would allow use to solve for the pressure distribution, then combined it with Darcy's law. How does that work with our conception so far? Well, conservation of mass in a 1D mesh, assuming a constant cross-sectional area (i.e. all the faces have the same area), dictates that the velocity at both faces of cell i be equal to each other:We can combine this with the preceding equation to get our pressure relations. Since the cell of interest is cell i, we need Pi on one side and all the other terms on the other side:At the boundaries, the pressures are given so the boundary cells have slightly different terms: the inner faces are interior faces so their factors don't change. For the outer (boundary) faces, the pressure at the face is known so the velocity calculation is easy there. For the most left cell (at origin), Pi is calculated as:Basic Solution using Gauss-SeidelWe have equations for the pressure of each cell in terms of each other, thereby creating a system of algebraic equations. If we had 3 or 4, we could solve them by hand by plugging in pressures we know for equations we don't. But that gets less efficient the finer the mesh becomes. That being said, the system of equations we have now allows us to debug in a straightforward manner by checking each individual calculation. Let's use that to our advantage now and use some more sophisticated methods later.The most straightforward method I can think of to solve a system of algebraic equations is the Gauss-Seidel method. Skipping to the end, you substitute values of variables you do know forward into equations you do not. So, in our case, we know the inlet pressure (P0) so we can use that to find the pressure at the adjacent cell center P1. Notice though, that the pressure at that cell is also a function of the pressure at the next cell P2 that we do not know. So, we have a to make an initial guess then calculate this once or even multiple times. More reading is available at Gauss-Seidel’s wiki but some important points are:  Gauss-Seidel is an iterative method requiring repeated solution of the same equations with changing variables  Solutions (should1) improve with successive iterations until error is below some tolerance (convergence)  The number of iterations it takes to convergence depends on the quality of the initial guessSo we've prepped the math, let's jump to the code. First, the pseudocode:# Solver Parameterstol = 1E-6 # tolerance to determining stopping point of schemeres = 1.0 # residual (initially greater than the tolerancemax_iter = 1000 # max iterations (so it doesn't go forever)k = 0 # iteration counter## Initializep[2:N-1] = zeros(N-2,1) # initial guess for cell centers## Iteration Loopdo while ((res&gt;tol)&amp;&amp;(k&lt;max_iter))  p_prev = p # previous iteration  for i in range(1,N-1)    Aw = ... # \"west\" factor (i-1)\tAe = ... # \"east\" factor (i+1)\tAp = Aw + Ae # center factor (i)    p[i] = (Aw*p[i-1] + Ae*p[i+1])/Ap  end  res = sum(abs(p-p_prev)) # L2 norm of p_diff  k += 1 # increase iteration countend doWe first define the solver parameters: tol and max_iter define how soon the iteration loop terminates, depending either on convergence (tol) or a maximum iteration count. res and k represents how the scheme is doing and whichever reaches its limit sooner terminates the loop. Then, we initialize the middle mesh points’ solution. Since we have pressure boundaries, p[0] and p[N-1] are already solved. Since we do not know how many iterations it will take to get a converged pressure, we use a while loop as the outer loop with the residual (defined here as the L2-norm of the change in the pressure vector per iteration) as the main escape condition. The iteration count is insurance so the program doesn’t hang here.Inside the loop, the Gauss-Seidel method allows the use of the next iteration’s solution (p[i+1], p[i-1]) so the equations are are continually changing based on new data. There is another simple iterative method called the Jacobi method where the previous iteration’s solution (p_prev in the pseudocode) is used to calculate the next iteration. The difference then becomes convergence speed, where Gauss-Seidel is generally faster.So what does this look like in Python? Not too different from the pseudocode but it is adjusted for better debugging:def gauss_seidel(self,msh,pm): # need the mesh info and porous medium permeability        # Solver Parameters        tol = 1E-6 # tolerance to determining stopping point of scheme        res = np.array([1.0],dtype=float) # residual (initially greater than the tolerance        max_iter = 100 # max iterations (so it doesn't go forever)        k = 0 # iteration counter        # self.p[2:N-1] = zeros(N-2,1) # initial guess for cell centers        p_samp = np.zeros([1,4],dtype=float)        p_samp[0][:] = np.copy([self.p[1],self.p[3],self.p[msh.Nx-4],self.p[msh.Nx-2]])        # p_samp[0][0] = np.copy(self.p[1])        # p_samp[0][1] = np.copy(self.p[3])        # p_samp[0][2] = np.copy(self.p[msh.Nx-4])        # p_samp[0][3] = np.copy(self.p[msh.Nx-2])                ## Iteration Loop        while ((res[k]&gt;tol)and(k&lt;max_iter)):            p_prev = np.copy(self.p)# previous iteration (copy to avoid using same mem loc)            i = 1 # first cell center            fw = -pm.K[i]/self.mu[i]/(msh.x[i]-msh.xc[i]) # f_i-1/2 -&gt; f_i            fe = -pm.K[i]/self.mu[i]/(msh.xc[i+1]-msh.x[i]) # f_i -&gt; f_i+1/2            fee = -pm.K[i+1]/self.mu[i+1]/(msh.x[i+1]-msh.xc[i+1]) #f_i+1/2 -&gt; f_i+1            Aw = fw            Ae = fe*fee/(fe+fee)            self.p[i] = (Aw*self.p[i-1] + Ae*self.p[i+1])/(Aw + Ae)            for i in range(2,msh.Nx-2):                fww = -pm.K[i-1]/self.mu[i-1]/(msh.xc[i]-msh.x[i-1]) # f_i-1-&gt;i-1/2                fw = -pm.K[i]/self.mu[i]/(msh.x[i]-msh.xc[i]) # f_i-1/2 -&gt; f_i                fe = -pm.K[i]/self.mu[i]/(msh.xc[i+1]-msh.x[i]) # f_i -&gt; f_i+1/2                fee = -pm.K[i+1]/self.mu[i+1]/(msh.x[i+1]-msh.xc[i+1]) # f_i+1/2 -&gt; f_i+1                Aw = fw*fww/(fw+fww) # \"west\" factor (i-1 -&gt; i)                Ae = fe*fee/(fe+fee) # \"east\" factor (i -&gt; i+1)                self.p[i] = (Aw*self.p[i-1] + Ae*self.p[i+1])/(Aw + Ae)            i = msh.Nx-2 # last cell center            fww = -pm.K[i-1]/self.mu[i-1]/(msh.xc[i]-msh.x[i-1]) # f_i-1-&gt;i-1/2            fw = -pm.K[i]/self.mu[i]/(msh.x[i]-msh.xc[i]) # f_i-1/2 -&gt; f_i            fe = -pm.K[i]/self.mu[i]/(msh.xc[i+1]-msh.x[i]) # f_i -&gt; f_i+1/2            Aw = fw*fww/(fw+fww)             Ae = fe             self.p[i] = (Aw*self.p[i-1] + Ae*self.p[i+1])/(Aw + Ae)            p_samp = np.append(p_samp,[[self.p[1],self.p[3],self.p[msh.Nx-4],self.p[msh.Nx-2]]],axis=0)            res = np.append(res,[sum(abs(self.p-p_prev))]) # L2 norm of p_diff            k += 1 # increase iteration count            # print(k,res[k-1])                    # Iterations are complete. Now for output        print('Gauss-Seidel Complete. Iteration, Residual:',k,res[k])                # I suggest using the pandas library for output to file. Compare the code below to the output        # function coded from scratch in the mesh class        res_vec = res[:,np.newaxis]        df = pd.DataFrame(np.append(res_vec,p_samp,axis=1),columns=['res','x1','x3','x_N-4','x_N-2'])        df.to_csv('GS_Out.csv',sep='\\t')               return [k,res[k]]The solver parameters remain the same but I've added a pressure sampling array so that I can look at some exact numbers at different iterations. The coefficients Ae and Aw have also been constructed from factors representing what happens in halves of cells: fww represents the right half of the left cell, fw represents the left half of the center cell, and so on. The outermost cells have their pressures calculated outside of the loop, acknowledging that their outer faces are actually boundaries.  After the iteration loop, I report some data to the terminal (through print) and to a csv file through a pandas function. I hope you notice the much shorter code for outputting to a file with pandas compared to the scratch function in the mesh class. My recommendation: if you can't help fighting with your code, find tools that help you avoid those debugging battles.Since we're object-oriented, we can call this method quite easily using:## Pressure calculation using Gauss-Seidelfl_gs = fluid(base_mesh,base.fl)print('Original P:',fl_gs.p[0:4],      fl_gs.p[base_mesh.Nx-5:base_mesh.Nx-1])&gt;&gt;&gt; Original P: [0. 0. 0. 0.] [0. 0. 0. 0.][itera, res] = fl_gs.gauss_seidel(base_mesh,pm1)print('Gauss-Seidel P:',fl_gs.p[0:4],      fl_gs.p[base_mesh.Nx-5:base_mesh.Nx-1])&gt;&gt;&gt; Gauss-Seidel Complete. Iteration, Residual: 100 5.65338582708514&gt;&gt;&gt; Gauss-Seidel P: [ 0.         -0.00138227 -0.00462155 -0.00872932] [-80.27557742 -85.87430752 -91.51599336 -97.17199779]Remembering our desired solution, it seems the scheme is way off. What's  going on? Remember, Gauss-Seidel is an iterative method, meaning it gets closer and closer to its solution with each iteration. We can run it 2 more times and compare the pressures to see this process:[itera, res] = fl_gs.gauss_seidel(base_mesh,pm1)print('Gauss-Seidel P:',fl_gs.p[0:4],      fl_gs.p[base_mesh.Nx-5:base_mesh.Nx-1])fl_gs2 = copy.deepcopy(fl_gs) # another 100 iterations[itera, res] = fl_gs2.gauss_seidel(base_mesh,pm1)fl_gs3 = copy.deepcopy(fl_gs2) # another 100 iterations[itera, res] = fl_gs3.gauss_seidel(base_mesh,pm1)&gt;&gt;&gt; Plotting Code Here. Refer to Gauss_Seidel_Solve.py in Github Repo &lt;&lt;&lt;The initial condition is the zero condition, which is good for the inlet but  far from the outlet solution. Since the solutions of individual nodes are determined by the neighbor, getting the final solution using this iterative method requires “communication” between the nodes, and it takes a while for this to occur.So, at the very least, it is moving towards the correct solution, iteration by iteration. But this isn't an efficient way of solving it. Giving a better initial condition would definitely help and using better solution algorithms/methods can help. The successive over-relaxation (SOR) method takes a small step from the Gauss-Seidel method but, with some matrix set-up, I recommend using a direct solver.In any case, our code/method works. It took some work to get here so let's try a problem that we don't know the answer to. Assume the viscosity changes linearly according to:where g and b are constants. In truth, we can do some calculus and differential equation work to get the solution but, at first glance, it's not apparent what the solution should be. Even if you don't want to do the math, you can check the pressure solution by simply calculating the velocities at the faces to ensure they are constant.class fluid():...    def mu_lin(self,mesh):        N = mesh.Nx        L = mesh.x[N-1]        L0 = mesh.x[0]        for i in range(1,N):            self.mu[i] = (0.005-0.001)/(L-L0)*mesh.x[i]+0.001...fl_gs_mulin = fluid(base_mesh,base.fl)print('Original P:',fl_gs_mulin.p[0:4],      fl_gs_mulin.p[base_mesh.Nx-5:base_mesh.Nx-1])fl_gs_mulin.p_lin(base_mesh)print('Linear P:',fl_gs_mulin.p[0:4],      fl_gs_mulin.p[base_mesh.Nx-5:base_mesh.Nx-1])fl_gs_mulin.mu_lin(base_mesh)for k in range(0,51): [itera, res] = fl_gs_mulin.gauss_seidel(base_mesh,pm1)print('Final P:',fl_gs_mulin.p[0:4],      fl_gs_mulin.mu[base_mesh.Nx-5:base_mesh.Nx-1])&gt;&gt;&gt; Original P: [0. 0. 0. 0.] [0. 0. 0. 0.]&gt;&gt;&gt; Linear P: [ 0. -1. -3. -5.] [-93. -95. -97. -99.]...&gt;&gt;&gt; Gauss-Seidel Complete. Iteration, Residual: 1 9.391120880941628e-08&gt;&gt;&gt; Final P: [ 0.         -0.33986983 -1.05987099 -1.83320556] [0.00472 0.0048  0.00488 0.00496].&gt;&gt;&gt; Code to Plot mu, p, and u, also in the Gauss_Seidel_Solve.py file in Github Repo &lt;&lt;&lt;The pressure distribution is different now, but of course, the changing viscosity means that the pressure distribution must be higher in some places to maintain the same velocity throughout (remember, continuity equation/conservation of mass). This is reflected in the constant velocity profile shown below:In the next blog post, we'll use more efficient extant tools to solve this problem.Footnotes            To solve a linear system using the Gauss-Seidel method (or any of the methods I'll be discussing), the coefficient matrix needs to be diagonally dominant or symmetric positive definite. Otherwise, the code will not converge to a solution. This is a bit technical so just know, for the systems of equations I set up (where solutions at indivdual points are only calculated based on their neighbors), the matrices are always diagonally dominant. I urge caution before trying to use this on a linear system with random values or some “easy” linear system coming from a textbook. &#8617;      ",
            "content_html": "<p>While the code we've developed so far allows us to go from parameters to plots in a few lines (assuming that all the classes and their methods are coded), the code also makes the assumption that the pressure is linear, which may not be true. To add more functionality to the code, let's figure out how to solve for the pressure distribution and velocity given only the parameters of the porous medium and the inlet and outlet conditions.</p><h3 id=\"math\">Math</h3><p>If the pressure is also unknown, then we need another equation to solve for pressure. So far, we've only used Darcy's Law. However, the assumptions of Darcy's law (slow flow through a porous medium) allow us to use another equation that accounts for mass conservation: the incompressible continuity equation:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?\\nabla\\cdot\\vec{u}&space;=&space;0\" /></p><p>Since our case is 1D, we can simplify this to:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?\\dfrac{\\partial u}{\\partial x}&space;=&space;0\" /></p><p>This means that the velocity in the pipe is constant in the x-direction, which we knew before. What we want to find is the pressure distribution so we need to plug in Darcy's law into the simplified equation above:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?\\dfrac{\\partial u}{\\partial x}&space;=&space;\\dfrac{\\partial}{\\partial x}(-\\dfrac{K}{\\mu}\\dfrac{dP}{dx})&space;=&space;0\" /></p><p>Our method from last week does not assume that the porous medium/liquid properties are constant so we'll keep the permeability and viscosity inside the parentheses. However, we can guess what the pressure distribution would be if we did. For now, let's move on to the equations that will be solved in Python.</p><p>In the previous <a href=\"https://tim-munuhe.github.io/2021/05/14/mesh-fluidpm-plot\">post</a>, the velocity at the faces between the pressure points was coded but only briefly discussed. Let's flesh out the idea a bit more fully:</p><p>The mesh consists of individual cells that meet at their left and right faces, as in the figure below:</p><p><img src=\"../../../assets/images/Mid_mesh.png\" alt=\"Mid-mesh figure\" title=\"Cells and faces in middle of mesh\" /></p><p>The middle cell experiences flow inwards from the left and outwards to the right. The adjacent cells have their own properties (K and mu specifically) so the pressure gradients within the cells may be different even though they have the same flow velocity (Darcy's Law). However, you also know that the pressure at the face is equal for both cell, so at face <em>i+0.5</em>:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?u_{i+0.5}&space;=&space;\\dfrac{-K_i}{\\mu_i}\\dfrac{P_{i+0.5}-P_i}{\\triangle x/2}&space;=&space;\\dfrac{-K_{i+1}}{\\mu_{i+1}}\\dfrac{P_{i+1}-P_{i+0.5}}{\\triangle x/2}\" /></p><p>We don't know the pressure at the face so we need to remove it so that we have an <em>equivalent</em> permeability/viscosity factor that accounts for both cells. Luckily, we know K and mu in both cells so we can do some algebra to get the velocity across the face in terms of the adjacent cell pressures:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?u_{i+0.5}\\;=\\;-\\dfrac{f_i%20f_{i+1}}{f_i+f_{i+1}}(P_{i+1}-P_i),\\;\\;\\;\\;\\;f_i&space;=&space;%20\\dfrac{K_{i}}{\\mu_{i}}\\dfrac{1}{x_{i+0.5}-x_i}\" /></p><p>This expression will take care of all interior faces.</p><p>I wrote at the beginning that the continuity equation would allow use to solve for the pressure distribution, then combined it with Darcy's law. How does that work with our conception so far? Well, conservation of mass in a 1D mesh, assuming a constant cross-sectional area (i.e. all the faces have the same area), dictates that the velocity at both faces of cell <em>i</em> be equal to each other:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?u_{i-0.5}\\;=\\;u_{i+0.5}\" /></p><p>We can combine this with the preceding equation to get our pressure relations. Since the cell of interest is cell <em>i</em>, we need <em>P<sub>i</sub></em> on one side and all the other terms on the other side:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?P_i\\;=\\;\\dfrac{\\dfrac{f_{i+1}f_i}{f_{i+1}+f_i}P_{i+1}+\\dfrac{f_{i-1}f_i}{f_{i-1}+f_i}P_{i-1}} {\\dfrac{f_{i+1}f_i}{f_{i+1}+f_i}+\\dfrac{f_{i-1}f_i}{f_{i-1}+f_i}}\" /></p><p>At the boundaries, the pressures are given so the boundary cells have slightly different terms: the inner faces are interior faces so their factors don't change. For the outer (boundary) faces, the pressure at the face is known so the velocity calculation is easy there. For the most left cell (at origin), <em>P<sub>i</sub></em> is calculated as:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?P_i\\;=\\;\\dfrac{\\dfrac{f_{i+1}f_i}{f_{i+1}+f_i}P_{i+1}+f_iP_0}{\\dfrac{f_{i+1}f_i}{f_{i+1}+f_i}+f_i}\" /></p><h3 id=\"basic-solution-using-gauss-seidel\">Basic Solution using Gauss-Seidel</h3><p>We have equations for the pressure of each cell in terms of each other, thereby creating a system of algebraic equations. If we had 3 or 4, we could solve them by hand by plugging in pressures we know for equations we don't. But that gets less efficient the finer the mesh becomes. That being said, the system of equations we have now allows us to debug in a straightforward manner by checking each individual calculation. Let's use that to our advantage now and use some more sophisticated methods later.</p><p>The most straightforward method I can think of to solve a system of algebraic equations is the <a href=\"https://en.wikipedia.org/wiki/Gauss%E2%80%93Seidel_method\">Gauss-Seidel method</a>. Skipping to the end, you substitute values of variables you do know forward into equations you do not. So, in our case, we know the inlet pressure (<em>P<sub>0</sub></em>) so we can use that to find the pressure at the adjacent cell center <em>P<sub>1</sub></em>. Notice though, that the pressure at that cell is also a function of the pressure at the next cell <em>P<sub>2</sub></em> that we do not know. So, we have a to make an initial guess then calculate this once or even multiple times. More reading is available at Gauss-Seidel’s <a href=\"https://en.wikipedia.org/wiki/Gauss%E2%80%93Seidel_method\">wiki</a> but some important points are:</p><ul>  <li>Gauss-Seidel is an iterative method requiring repeated solution of the same equations with changing variables</li>  <li>Solutions (should<sup id=\"fnref:GS\" role=\"doc-noteref\"><a href=\"#fn:GS\" class=\"footnote\" rel=\"footnote\">1</a></sup>) improve with successive iterations until error is below some tolerance (convergence)</li>  <li>The number of iterations it takes to convergence depends on the quality of the initial guess</li></ul><p>So we've prepped the math, let's jump to the code. First, the pseudocode:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># Solver Parameterstol = 1E-6 # tolerance to determining stopping point of schemeres = 1.0 # residual (initially greater than the tolerancemax_iter = 1000 # max iterations (so it doesn't go forever)k = 0 # iteration counter## Initializep[2:N-1] = zeros(N-2,1) # initial guess for cell centers## Iteration Loopdo while ((res&gt;tol)&amp;&amp;(k&lt;max_iter))  p_prev = p # previous iteration  for i in range(1,N-1)    Aw = ... # \"west\" factor (i-1)\tAe = ... # \"east\" factor (i+1)\tAp = Aw + Ae # center factor (i)    p[i] = (Aw*p[i-1] + Ae*p[i+1])/Ap  end  res = sum(abs(p-p_prev)) # L2 norm of p_diff  k += 1 # increase iteration countend do</code></pre></div></div><p>We first define the solver parameters: tol and max_iter define how soon the iteration loop terminates, depending either on convergence (tol) or a maximum iteration count. res and k represents how the scheme is doing and whichever reaches its limit sooner terminates the loop. Then, we initialize the middle mesh points’ solution. Since we have pressure boundaries, p[0] and p[N-1] are already solved. Since we do not know how many iterations it will take to get a converged pressure, we use a while loop as the outer loop with the residual (defined here as the L2-norm of the change in the pressure vector per iteration) as the main escape condition. The iteration count is insurance so the program doesn’t hang here.</p><p>Inside the loop, the Gauss-Seidel method allows the use of the next iteration’s solution (p[i+1], p[i-1]) so the equations are are continually changing based on new data. There is another simple iterative method called the Jacobi method where the previous iteration’s solution (p_prev in the pseudocode) is used to calculate the next iteration. The difference then becomes convergence speed, where Gauss-Seidel is generally faster.</p><p>So what does this look like in Python? Not too different from the pseudocode but it is adjusted for better debugging:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>def gauss_seidel(self,msh,pm): # need the mesh info and porous medium permeability        # Solver Parameters        tol = 1E-6 # tolerance to determining stopping point of scheme        res = np.array([1.0],dtype=float) # residual (initially greater than the tolerance        max_iter = 100 # max iterations (so it doesn't go forever)        k = 0 # iteration counter        # self.p[2:N-1] = zeros(N-2,1) # initial guess for cell centers        p_samp = np.zeros([1,4],dtype=float)        p_samp[0][:] = np.copy([self.p[1],self.p[3],self.p[msh.Nx-4],self.p[msh.Nx-2]])        # p_samp[0][0] = np.copy(self.p[1])        # p_samp[0][1] = np.copy(self.p[3])        # p_samp[0][2] = np.copy(self.p[msh.Nx-4])        # p_samp[0][3] = np.copy(self.p[msh.Nx-2])                ## Iteration Loop        while ((res[k]&gt;tol)and(k&lt;max_iter)):            p_prev = np.copy(self.p)# previous iteration (copy to avoid using same mem loc)            i = 1 # first cell center            fw = -pm.K[i]/self.mu[i]/(msh.x[i]-msh.xc[i]) # f_i-1/2 -&gt; f_i            fe = -pm.K[i]/self.mu[i]/(msh.xc[i+1]-msh.x[i]) # f_i -&gt; f_i+1/2            fee = -pm.K[i+1]/self.mu[i+1]/(msh.x[i+1]-msh.xc[i+1]) #f_i+1/2 -&gt; f_i+1            Aw = fw            Ae = fe*fee/(fe+fee)            self.p[i] = (Aw*self.p[i-1] + Ae*self.p[i+1])/(Aw + Ae)            for i in range(2,msh.Nx-2):                fww = -pm.K[i-1]/self.mu[i-1]/(msh.xc[i]-msh.x[i-1]) # f_i-1-&gt;i-1/2                fw = -pm.K[i]/self.mu[i]/(msh.x[i]-msh.xc[i]) # f_i-1/2 -&gt; f_i                fe = -pm.K[i]/self.mu[i]/(msh.xc[i+1]-msh.x[i]) # f_i -&gt; f_i+1/2                fee = -pm.K[i+1]/self.mu[i+1]/(msh.x[i+1]-msh.xc[i+1]) # f_i+1/2 -&gt; f_i+1                Aw = fw*fww/(fw+fww) # \"west\" factor (i-1 -&gt; i)                Ae = fe*fee/(fe+fee) # \"east\" factor (i -&gt; i+1)                self.p[i] = (Aw*self.p[i-1] + Ae*self.p[i+1])/(Aw + Ae)            i = msh.Nx-2 # last cell center            fww = -pm.K[i-1]/self.mu[i-1]/(msh.xc[i]-msh.x[i-1]) # f_i-1-&gt;i-1/2            fw = -pm.K[i]/self.mu[i]/(msh.x[i]-msh.xc[i]) # f_i-1/2 -&gt; f_i            fe = -pm.K[i]/self.mu[i]/(msh.xc[i+1]-msh.x[i]) # f_i -&gt; f_i+1/2            Aw = fw*fww/(fw+fww)             Ae = fe             self.p[i] = (Aw*self.p[i-1] + Ae*self.p[i+1])/(Aw + Ae)            p_samp = np.append(p_samp,[[self.p[1],self.p[3],self.p[msh.Nx-4],self.p[msh.Nx-2]]],axis=0)            res = np.append(res,[sum(abs(self.p-p_prev))]) # L2 norm of p_diff            k += 1 # increase iteration count            # print(k,res[k-1])                    # Iterations are complete. Now for output        print('Gauss-Seidel Complete. Iteration, Residual:',k,res[k])                # I suggest using the pandas library for output to file. Compare the code below to the output        # function coded from scratch in the mesh class        res_vec = res[:,np.newaxis]        df = pd.DataFrame(np.append(res_vec,p_samp,axis=1),columns=['res','x1','x3','x_N-4','x_N-2'])        df.to_csv('GS_Out.csv',sep='\\t')               return [k,res[k]]</code></pre></div></div><p>The solver parameters remain the same but I've added a pressure sampling array so that I can look at some exact numbers at different iterations. The coefficients Ae and Aw have also been constructed from factors representing what happens in halves of cells: fww represents the right half of the left cell, fw represents the left half of the center cell, and so on. The outermost cells have their pressures calculated outside of the loop, acknowledging that their outer faces are actually boundaries.  After the iteration loop, I report some data to the terminal (through print) and to a csv file through a pandas function. I hope you notice the much shorter code for outputting to a file with pandas compared to the scratch function in the mesh class. My recommendation: if you can't help fighting with your code, find tools that help you avoid those debugging battles.</p><p>Since we're object-oriented, we can call this method quite easily using:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>## Pressure calculation using Gauss-Seidelfl_gs = fluid(base_mesh,base.fl)print('Original P:',fl_gs.p[0:4],      fl_gs.p[base_mesh.Nx-5:base_mesh.Nx-1])&gt;&gt;&gt; Original P: [0. 0. 0. 0.] [0. 0. 0. 0.][itera, res] = fl_gs.gauss_seidel(base_mesh,pm1)print('Gauss-Seidel P:',fl_gs.p[0:4],      fl_gs.p[base_mesh.Nx-5:base_mesh.Nx-1])&gt;&gt;&gt; Gauss-Seidel Complete. Iteration, Residual: 100 5.65338582708514&gt;&gt;&gt; Gauss-Seidel P: [ 0.         -0.00138227 -0.00462155 -0.00872932] [-80.27557742 -85.87430752 -91.51599336 -97.17199779]</code></pre></div></div><p>Remembering our desired solution, it seems the scheme is way off. What's  going on? Remember, Gauss-Seidel is an iterative method, meaning it gets closer and closer to its solution with each iteration. We can run it 2 more times and compare the pressures to see this process:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>[itera, res] = fl_gs.gauss_seidel(base_mesh,pm1)print('Gauss-Seidel P:',fl_gs.p[0:4],      fl_gs.p[base_mesh.Nx-5:base_mesh.Nx-1])fl_gs2 = copy.deepcopy(fl_gs) # another 100 iterations[itera, res] = fl_gs2.gauss_seidel(base_mesh,pm1)fl_gs3 = copy.deepcopy(fl_gs2) # another 100 iterations[itera, res] = fl_gs3.gauss_seidel(base_mesh,pm1)&gt;&gt;&gt; Plotting Code Here. Refer to Gauss_Seidel_Solve.py in Github Repo &lt;&lt;&lt;</code></pre></div></div><p><img src=\"../../../assets/images/p_comp.png\" alt=\"Comparison Plot of P: True solution vs. GS.\" title=\"Pressure vs. x.\" /></p><p>The initial condition is the zero condition, which is good for the inlet but  far from the outlet solution. Since the solutions of individual nodes are determined by the neighbor, getting the final solution using this iterative method requires “communication” between the nodes, and it takes a while for this to occur.So, at the very least, it is moving towards the correct solution, iteration by iteration. But this isn't an efficient way of solving it. Giving a better initial condition would definitely help and using better solution algorithms/methods can help. The successive over-relaxation (SOR) method takes a small step from the Gauss-Seidel method but, with some matrix set-up, I recommend using a direct solver.</p><p>In any case, our code/method works. It took some work to get here so let's try a problem that we don't know the answer to. Assume the viscosity changes linearly according to:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?\\mu\\;=\\;gx+b\" /></p><p>where <em>g</em> and <em>b</em> are constants. In truth, we can do some calculus and differential equation work to get the solution but, at first glance, it's not apparent what the solution should be. Even if you don't want to do the math, you can check the pressure solution by simply calculating the velocities at the faces to ensure they are constant.</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>class fluid():...    def mu_lin(self,mesh):        N = mesh.Nx        L = mesh.x[N-1]        L0 = mesh.x[0]        for i in range(1,N):            self.mu[i] = (0.005-0.001)/(L-L0)*mesh.x[i]+0.001...fl_gs_mulin = fluid(base_mesh,base.fl)print('Original P:',fl_gs_mulin.p[0:4],      fl_gs_mulin.p[base_mesh.Nx-5:base_mesh.Nx-1])fl_gs_mulin.p_lin(base_mesh)print('Linear P:',fl_gs_mulin.p[0:4],      fl_gs_mulin.p[base_mesh.Nx-5:base_mesh.Nx-1])fl_gs_mulin.mu_lin(base_mesh)for k in range(0,51): [itera, res] = fl_gs_mulin.gauss_seidel(base_mesh,pm1)print('Final P:',fl_gs_mulin.p[0:4],      fl_gs_mulin.mu[base_mesh.Nx-5:base_mesh.Nx-1])&gt;&gt;&gt; Original P: [0. 0. 0. 0.] [0. 0. 0. 0.]&gt;&gt;&gt; Linear P: [ 0. -1. -3. -5.] [-93. -95. -97. -99.]...&gt;&gt;&gt; Gauss-Seidel Complete. Iteration, Residual: 1 9.391120880941628e-08&gt;&gt;&gt; Final P: [ 0.         -0.33986983 -1.05987099 -1.83320556] [0.00472 0.0048  0.00488 0.00496].&gt;&gt;&gt; Code to Plot mu, p, and u, also in the Gauss_Seidel_Solve.py file in Github Repo &lt;&lt;&lt;</code></pre></div></div><p><img src=\"../../../assets/images/node_conv_mu_P.png\" alt=\"mu and converged P for GS and linear viscosity.\" title=\"mu/P vs. x.\" /></p><p>The pressure distribution is different now, but of course, the changing viscosity means that the pressure distribution must be higher in some places to maintain the same velocity throughout (remember, continuity equation/conservation of mass). This is reflected in the constant velocity profile shown below:</p><p><img src=\"../../../assets/images/face_conv_u.png\" alt=\"converged u for GS and linear viscosity.\" title=\"u vs. x.\" /></p><p>In the next blog post, we'll use more efficient extant tools to solve this problem.</p><h4 id=\"footnotes\">Footnotes</h4><div class=\"footnotes\" role=\"doc-endnotes\">  <ol>    <li id=\"fn:GS\" role=\"doc-endnote\">      <p>To solve a linear system using the Gauss-Seidel method (or any of the methods I'll be discussing), the coefficient matrix needs to be diagonally dominant or symmetric positive definite. Otherwise, the code will not converge to a solution. This is a bit technical so just know, for the systems of equations I set up (where solutions at indivdual points are only calculated based on their neighbors), the matrices are always diagonally dominant. I urge caution before trying to use this on a linear system with random values or some “easy” linear system coming from a textbook. <a href=\"#fnref:GS\" class=\"reversefootnote\" role=\"doc-backlink\">&#8617;</a></p>    </li>  </ol></div>",
            "url": "tim-munuhe.github.io/2021/06/07/solve-1d-darcy-continuity",
            
            
            
            
            
            "date_published": "2021-06-07T00:00:00-04:00",
            "date_modified": "2021-06-07T00:00:00-04:00",
            
                "author":  {
                "name": "Timothy W. Munuhe, Ph.D.",
                "url": "tim-munuhe.gitub.io",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "tim-munuhe.github.io/2021/05/14/mesh-fluidpm-plot",
            "title": "Basic Python with Darcy's Law - Meshing, Basic Spatial Solutions, and Plotting Output",
            "summary": "Form the mesh objects, calculate a basic solution over the mesh, and plot the output.",
            "content_text": "Now that we have some practice with objects in Python and Darcy’s law, we can create a program that is more expandable and useful. Since this is a physical problem, we need to consider space in our code. So, we need to add a mesh to represent the porous medium and the fluid inside its pores. We also need to output data as plots for immediate review and in a way that other programs can read.More classes and objects can get unwieldy, so let's develop a sketch of how the program is going to work overall so we can code effectively. First, a text description: the user (you, or me) is going to create a case file that the csv.Dictreader function will read into Python listing case parameters.  A case object will be instantiated using that data just read. This is as far as we got in the previous post. Now, we can create a mesh (object) representing the space filled with the fluid (object) and solid material/matrix (object). All three objects' parameters will be determined by that parameters specified in the case file. Since the fluid is the only one flowing, Darcy's Law will be called on it to calculate the pressure and flow velocity at the locations specified by the mesh. Lastly, relevant properties will be output to a file that the user can plot or analyze.Simple, right? Remember, one step at a time.The MeshThe mesh can represent a 1D, 2D, or 3D space. Assume we have a cylindrical pipe filled with sand and water. Depending on its width, diameter, and how homogeneous the sand is, we might want to consider it in 3D or 2D. If we also assume the pipe is very long relative to its diameter, we can simplify the problem to 1D. A 1D mesh is essentially a line with points along it while the 2D and 3D spaces can be divided into a variety of 2D and 3D shapes (squares and cubes being particularly common). So, each element of the 1D mesh represents a slice of the pipe.I'll be using finite difference method for the majority of the blog posts. There's more math here than I care to dig into but I recommend reading Patankar &amp; Spalding’s 1972 paper titled “A Calculation Procedure for Heat, Mass, and Momentum Transfer”. In short, from Darcy’s Law, the pressure gradient is used to calculate the velocity. So, the velocity and pressure are more accurately considered at offset locations, for example on a staggered mesh. That is, where you calculate the velocity is offset from where you calculate the pressures. So, you use the pressures at two adjacent cells to calculate the (volume-averaged) velocity at the face between those cells. You can do this to get the velocities at the interior faces. At the inlet and outlet, the inlet pressure and velocity are collocated which may affect the accuracy. That is not important for the current code but, for better-than-1st-order accuracy, we'd need to derive a better approximation for the pressure gradients there. In any case, CFD-Online has a pretty short article about the staggered grid issue.Back to the OOP: we create a mesh class where each mesh object has a name, shape, density, and specified node (x), interior face (xc), and boundary locations (also xc):class mesh(): # mesh class    def __init__(self,case): # Take in the case info for certain params        dim = 1 # case.dim        if (dim == 1):            self.Nx = int((case.xL - case.x0)/case.dx + 2.0)                    # Face locations            self.xc = np.ones(self.Nx)*case.x0# Initialize mesh            self.xc[self.Nx-1] = case.xL # Outward boundary            for i in range(2,self.Nx-1):                 self.xc[i] = (i-1)*case.dx # Cell Face Locations            # Node locations            self.x = np.copy(self.xc) # Initialize mesh            for i in range(0,self.Nx-1):                self.x[i] = (self.xc[i+1] + self.xc[i])/2 # Cell Node Locations: halfway between faces            self.x[self.Nx-1] = np.copy(self.xc[self.Nx-1]) # Outward boundary        def output(self,fname): # output mesh        with open(fname,'w', newline='') as csvfile:            mesh_write = csv.writer(csvfile,dialect = 'excel', delimiter = '\\t') # writer object            mesh_write.writerow(['i', 'x', 'xc']) # header row            for i in range(0,self.Nx):                mesh_write.writerow([i+1,self.x[i],self.xc[i]]) # actual data rowsThe mesh consists of nodes and faces: the number of nodes is the number of slices the make the pipe plus 2. Why the plus 2? There are two additional nodes at the inlet and outlet. There is one less face but, to keep the indices and array lengths the same, the inlet face is duplicated. This helps with coding and that first face can be ignored for the most part. The mesh requires a case object for its instantiation, so we create the mesh object using base_mesh = mesh(base). Let’s ask for some information, just to make sure everything ran smoothly:print('Node Locations w/ inlet:', base_mesh.x[0:5]) # check inlet location and spacingprint('Nx:', base_mesh.Nx) # check number of elementsprint('Outlet Location:', base_mesh.x[base_mesh.Nx-1])print('Face Locations:', base_mesh.xc[0:5]) &gt;&gt;&gt; Node Locations w/ inlet: [0.   0.01 0.03 0.05 0.07]&gt;&gt;&gt; Nx: 52&gt;&gt;&gt; Outlet Location: 1.0&gt;&gt;&gt; Face Locations: [0.   0.   0.02 0.04 0.06]The number of elements is correct, the inlet face is duplicated, and the spacing for the interior node locations is correct. For the calculations to follow, we just have to remember the offset between the node and face indices for our accuracy. Now we can output this to a file that another program can use, maybe for visualization, by calling the output method that's also in the mesh class: base_mesh.output('base_mesh.dat')If everything works, the first six lines of your .dat file will be:i\tx\txc1\t0.0\t0.02\t0.01\t0.03\t0.03\t0.024\t0.05\t0.045\t0.07\t0.06If you’re using excel, you can output a csv file: go to the Data tab and do text-to-columns on all the rows with a tab delimiter to get it formatted.Applying Darcy's Law as a Method to a Fluid ObjectBecause the porous medium and fluid occupy the space of the mesh, they need to have some of the same properties as the mesh, namely the shape and spatial positions of the mesh. Then, the pressure at p[i] is the pressure at the location x[i]. Apart from the size and shape, the fluid and porous medium share a pressure and have their own properties as outlined in Darcy's Law. Both have their own names and volume fractions. The fluid will have a viscosity and velocity and the porous medium will have a permeability:class fluid(): # fluid class, can create multiple fluid objects for multiphase flow or other studies    def __init__(self,mesh,fluid_prop):        self.name = fluid_prop['Name']        # Initialize variables        self.p = np.ones(mesh.Nx)*fluid_prop['p0'] # Pressure        self.p[mesh.Nx-1] = fluid_prop['pL'] # Pressure boundary at x = L        self.u = np.ones(mesh.Nx)*fluid_prop['u0'] # Velocity: Staggered mesh so velocity at faces        self.mu = np.ones(mesh.Nx)*fluid_prop['mu'] # Viscosity    def p_lin(self,mesh):        N = mesh.Nx        L = mesh.x[N-1]        L0 = mesh.x[0]        for i in range(1,N):            self.p[i] = (self.p[N-1]-self.p[0])/(L-L0)*mesh.x[i]    def darcyv(self,mesh,pm):        N = mesh.Nx        self.u[0] = -pm.K[0]/self.mu[0]*(self.p[1]-self.p[0])/(mesh.x[1]-mesh.x[0]) # inlet        self.u[1] = self.u[0] # same location        for i in range(2,N-1): # interior faces            Ai = pm.K[i-1]/self.mu[i-1]/(mesh.xc[i]-mesh.x[i-1])            Ai1 = pm.K[i]/self.mu[i]/(mesh.x[i]-mesh.xc[i])            self.u[i] = -Ai*Ai1/(Ai+Ai1)*(self.p[i]-self.p[i-1])        self.u[N-1] = -pm.K[N-1]/self.mu[N-1]*(self.p[N-1]-self.p[N-2])/(mesh.x[N-1]-mesh.x[N-2]) # outletclass por_med(): # porous medium class, for parametric studies or composite porous media    def __init__(self,mesh,pm_prop):        self.name = pm_prop        # Initialize Variables        self.K = np.ones(mesh.Nx)*pm_prop['K'] # Permeability        self.eps = np.ones(mesh.Nx)*pm_prop['eps'] # Porosity...fl1 = fluid(base_mesh,base.fl) # fluid object, determined by mesh and case's fluid propertiespm1 = por_med(base_mesh,base.pm) # porous medium object, determined by mesh and case's porous medium propertiesWith the fluid and porous medium objects created, we can find the pressures and flow velocities within the domain at the points specified by the mesh. While we can do something similar to the direct calculation in in the first blog post, let’s create methods so that the functions are tied to the specific objects. This connects the equations to the specific parts of the problem more directly.Since the porous medium is homogeneous, we can assume that the pressure distribution in the porous medium is linear, with the boundary conditions in the case corresponding to the inlet and outlet pressures. Then, we can code a very simple pressure calculation method for the fluid below the instantiation, represented by the p_lin(mesh) method in the fluid class above:print('Initial Pressure:',fl1.p[0:4])fl1.p_lin(base_mesh)print('Linear Pressure:',fl1.p[0:4])&gt;&gt;&gt; Initial Pressure: [0. 0. 0. 0.]&gt;&gt;&gt; Linear Pressure: [ 0. -1. -3. -5.]At the faces (represented by xc) we can then calculate the velocities using the Darcy’s Law method also in the fluid class:print('Initial Velocity (correct):',fl1.u[0:4]) # velocity from initializationfl1.u = np.zeros(base_mesh.Nx) # zero out velocity fl1.darcyv(base_mesh,pm1) # use darcyv methodprint('Final Velocity:',fl1.u[0:4]) # print to confirm that darcyv did what it was supposed to (got same solution as initialization)&gt;&gt;&gt; Initial Velocity (correct): [1.e-04 1.e-04 1.e-04 1.e-04]&gt;&gt;&gt; Final Velocity: [1.e-04 1.e-04 1.e-04 1.e-04]The darcyv method as it is coded looks complicated but it's pretty simple mathematically. The changes made from just applying Darcy's law from the previous post (-K/mu*dP/dx) directly allow it to handle nonhomogeneous porous media and meshes of varying element size, which we might want to do later.Matplotlib OutputWe’ve already gone over outputting results to data. What if you just want some quick results to confirm that everything makes sense? With 1D data, creating line plots will give us faster results. To let us know whether everything went well.The class formation format we’ve used so far has been somewhat cumbersome due to all the parameters. Now, I just want to collect the solution to be output to an object that I can pass to a plotting function. To make the solution object, I can use metaprogramming with the type function:data_sol = type('sol', (object,), {})() # empty object (metaprogramming)data_sol.Np = 3 # Data at nodes: x p, K, mudata_sol.Nx = base_mesh.Nxdata_sol.varnamex = 'x (m)'data_sol.varname = ['p (Pa)', 'K ($m^2$)', '\\u03BC (Pa*s)']data_sol.x = base_mesh.xdata_sol.var = np.zeros((data_sol.Nx,data_sol.Np))data_sol.var = np.concatenate((fl1.p.reshape(data_sol.Nx,1)                               ,pm1.K.reshape(data_sol.Nx,1)                               ,fl1.mu.reshape(data_sol.Nx,1))                              ,axis=1)Here, I've created a new sol object data_sol that is initially empty. I’ve then filled it with the data I need to output and visualize, namely the pressure, permeability, and viscosity which are at the nodes. I want the velocity too but I need a different object to handle the variables calculated at the face. Corresponding code is in the Github repo for this. For now, let's focus on the plot. I can pass this sol object to a function that knows how to read it and create plots:def plot_out(data): # plotting function, takes in data object of specific form and prints plots    N_param = data.Np    N = data.Nx    fig, ax = plt.subplots(N_param,1,figsize=(4,5))        for i in range(0,N_param):        ax[i].plot(data.x, data.var[0:,i], color = 'black',linewidth=0.5)        ax[i].set_xlabel(data.varnamex,fontsize=12)         ax[i].set_ylabel(data.varname[i],fontsize=12)    fig.tight_layout()    plt.show()  ....plot_out(data_sol) # call the plotting outputNow that we can output text and figures to check our results, we can use more sophisticated numerical methods to get solutions to more complicated problem while debugging more efficiently.",
            "content_html": "<p>Now that we have some practice with objects in Python and Darcy’s law, we can create a program that is more expandable and useful. Since this is a physical problem, we need to consider space in our code. So, we need to add a mesh to represent the porous medium and the fluid inside its pores. We also need to output data as plots for immediate review and in a way that other programs can read.</p><p>More classes and objects can get unwieldy, so let's develop a sketch of how the program is going to work overall so we can code effectively. First, a text description: the user (you, or me) is going to create a case file that the csv.Dictreader function will read into Python listing case parameters.  A case object will be instantiated using that data just read. This is as far as we got in the previous post. Now, we can create a mesh (object) representing the space filled with the fluid (object) and solid material/matrix (object). All three objects' parameters will be determined by that parameters specified in the case file. Since the fluid is the only one flowing, Darcy's Law will be called on it to calculate the pressure and flow velocity at the locations specified by the mesh. Lastly, relevant properties will be output to a file that the user can plot or analyze.</p><p>Simple, right? Remember, one step at a time.</p><h3 id=\"the-mesh\">The Mesh</h3><p>The mesh can represent a 1D, 2D, or 3D space. Assume we have a cylindrical pipe filled with sand and water. Depending on its width, diameter, and how homogeneous the sand is, we might want to consider it in 3D or 2D. If we also assume the pipe is very long relative to its diameter, we can simplify the problem to 1D. A 1D mesh is essentially a line with points along it while the 2D and 3D spaces can be divided into a variety of 2D and 3D shapes (squares and cubes being particularly common). So, each element of the 1D mesh represents a slice of the pipe.</p><p>I'll be using finite difference method for the majority of the blog posts. There's more math here than I care to dig into but I recommend reading Patankar &amp; Spalding’s 1972 paper titled “A Calculation Procedure for Heat, Mass, and Momentum Transfer”. In short, from Darcy’s Law, the pressure gradient is used to calculate the velocity. So, the velocity and pressure are more accurately considered at offset locations, for example on a staggered mesh. That is, where you calculate the velocity is offset from where you calculate the pressures. So, you use the pressures at two adjacent cells to calculate the (volume-averaged) velocity at the face between those cells. You can do this to get the velocities at the interior faces. At the inlet and outlet, the inlet pressure and velocity are collocated which may affect the accuracy. That is not important for the current code but, for better-than-1st-order accuracy, we'd need to derive a better approximation for the pressure gradients there. In any case, <a href=\"https://www.cfd-online.com/Wiki/Staggered_grid\">CFD-Online has a pretty short article about the staggered grid issue</a>.</p><p>Back to the OOP: we create a mesh class where each mesh object has a name, shape, density, and specified node (x), interior face (xc), and boundary locations (also xc):</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>class mesh(): # mesh class    def __init__(self,case): # Take in the case info for certain params        dim = 1 # case.dim        if (dim == 1):            self.Nx = int((case.xL - case.x0)/case.dx + 2.0)                    # Face locations            self.xc = np.ones(self.Nx)*case.x0# Initialize mesh            self.xc[self.Nx-1] = case.xL # Outward boundary            for i in range(2,self.Nx-1):                 self.xc[i] = (i-1)*case.dx # Cell Face Locations            # Node locations            self.x = np.copy(self.xc) # Initialize mesh            for i in range(0,self.Nx-1):                self.x[i] = (self.xc[i+1] + self.xc[i])/2 # Cell Node Locations: halfway between faces            self.x[self.Nx-1] = np.copy(self.xc[self.Nx-1]) # Outward boundary        def output(self,fname): # output mesh        with open(fname,'w', newline='') as csvfile:            mesh_write = csv.writer(csvfile,dialect = 'excel', delimiter = '\\t') # writer object            mesh_write.writerow(['i', 'x', 'xc']) # header row            for i in range(0,self.Nx):                mesh_write.writerow([i+1,self.x[i],self.xc[i]]) # actual data rows</code></pre></div></div><p>The mesh consists of nodes and faces: the number of nodes is the number of slices the make the pipe plus 2. Why the plus 2? There are two additional nodes at the inlet and outlet. There is one less face but, to keep the indices and array lengths the same, the inlet face is duplicated. This helps with coding and that first face can be ignored for the most part. The mesh requires a case object for its instantiation, so we create the mesh object using <code class=\"language-python\">base_mesh = mesh(base)</code>. Let’s ask for some information, just to make sure everything ran smoothly:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>print('Node Locations w/ inlet:', base_mesh.x[0:5]) # check inlet location and spacingprint('Nx:', base_mesh.Nx) # check number of elementsprint('Outlet Location:', base_mesh.x[base_mesh.Nx-1])print('Face Locations:', base_mesh.xc[0:5]) &gt;&gt;&gt; Node Locations w/ inlet: [0.   0.01 0.03 0.05 0.07]&gt;&gt;&gt; Nx: 52&gt;&gt;&gt; Outlet Location: 1.0&gt;&gt;&gt; Face Locations: [0.   0.   0.02 0.04 0.06]</code></pre></div></div><p>The number of elements is correct, the inlet face is duplicated, and the spacing for the interior node locations is correct. For the calculations to follow, we just have to remember the offset between the node and face indices for our accuracy. Now we can output this to a file that another program can use, maybe for visualization, by calling the output method that's also in the mesh class: <code class=\"language-python\">base_mesh.output('base_mesh.dat')</code></p><p>If everything works, the first six lines of your <a href=\"https://github.com/tim-munuhe/Basic-Python-Darcys-Law/blob/main/Meshing_SpatialSol_Output/base_mesh.dat\">.dat file</a> will be:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>i\tx\txc1\t0.0\t0.02\t0.01\t0.03\t0.03\t0.024\t0.05\t0.045\t0.07\t0.06</code></pre></div></div><p>If you’re using excel, you can output a csv file: go to the Data tab and do text-to-columns on all the rows with a tab delimiter to get it formatted.</p><h3 id=\"applying-darcys-law-as-a-method-to-a-fluid-object\">Applying Darcy's Law as a Method to a Fluid Object</h3><p>Because the porous medium and fluid occupy the space of the mesh, they need to have some of the same properties as the mesh, namely the shape and spatial positions of the mesh. Then, the pressure at <code class=\"language-python\">p[i]</code> is the pressure at the location <code class=\"language-python\">x[i]</code>. Apart from the size and shape, the fluid and porous medium share a pressure and have their own properties as outlined in Darcy's Law. Both have their own names and volume fractions. The fluid will have a viscosity and velocity and the porous medium will have a permeability:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>class fluid(): # fluid class, can create multiple fluid objects for multiphase flow or other studies    def __init__(self,mesh,fluid_prop):        self.name = fluid_prop['Name']        # Initialize variables        self.p = np.ones(mesh.Nx)*fluid_prop['p0'] # Pressure        self.p[mesh.Nx-1] = fluid_prop['pL'] # Pressure boundary at x = L        self.u = np.ones(mesh.Nx)*fluid_prop['u0'] # Velocity: Staggered mesh so velocity at faces        self.mu = np.ones(mesh.Nx)*fluid_prop['mu'] # Viscosity    def p_lin(self,mesh):        N = mesh.Nx        L = mesh.x[N-1]        L0 = mesh.x[0]        for i in range(1,N):            self.p[i] = (self.p[N-1]-self.p[0])/(L-L0)*mesh.x[i]    def darcyv(self,mesh,pm):        N = mesh.Nx        self.u[0] = -pm.K[0]/self.mu[0]*(self.p[1]-self.p[0])/(mesh.x[1]-mesh.x[0]) # inlet        self.u[1] = self.u[0] # same location        for i in range(2,N-1): # interior faces            Ai = pm.K[i-1]/self.mu[i-1]/(mesh.xc[i]-mesh.x[i-1])            Ai1 = pm.K[i]/self.mu[i]/(mesh.x[i]-mesh.xc[i])            self.u[i] = -Ai*Ai1/(Ai+Ai1)*(self.p[i]-self.p[i-1])        self.u[N-1] = -pm.K[N-1]/self.mu[N-1]*(self.p[N-1]-self.p[N-2])/(mesh.x[N-1]-mesh.x[N-2]) # outletclass por_med(): # porous medium class, for parametric studies or composite porous media    def __init__(self,mesh,pm_prop):        self.name = pm_prop        # Initialize Variables        self.K = np.ones(mesh.Nx)*pm_prop['K'] # Permeability        self.eps = np.ones(mesh.Nx)*pm_prop['eps'] # Porosity...fl1 = fluid(base_mesh,base.fl) # fluid object, determined by mesh and case's fluid propertiespm1 = por_med(base_mesh,base.pm) # porous medium object, determined by mesh and case's porous medium properties</code></pre></div></div><p>With the fluid and porous medium objects created, we can find the pressures and flow velocities within the domain at the points specified by the mesh. While we can do something similar to the direct calculation in in the first blog post, let’s create methods so that the functions are tied to the specific objects. This connects the equations to the specific parts of the problem more directly.</p><p>Since the porous medium is homogeneous, we can assume that the pressure distribution in the porous medium is linear, with the boundary conditions in the case corresponding to the inlet and outlet pressures. Then, we can code a very simple pressure calculation method for the fluid below the instantiation, represented by the <code class=\"language-python\">p_lin(mesh)</code> method in the fluid class above:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>print('Initial Pressure:',fl1.p[0:4])fl1.p_lin(base_mesh)print('Linear Pressure:',fl1.p[0:4])&gt;&gt;&gt; Initial Pressure: [0. 0. 0. 0.]&gt;&gt;&gt; Linear Pressure: [ 0. -1. -3. -5.]</code></pre></div></div><p>At the faces (represented by <code class=\"language-python\">xc</code>) we can then calculate the velocities using the Darcy’s Law method also in the fluid class:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>print('Initial Velocity (correct):',fl1.u[0:4]) # velocity from initializationfl1.u = np.zeros(base_mesh.Nx) # zero out velocity fl1.darcyv(base_mesh,pm1) # use darcyv methodprint('Final Velocity:',fl1.u[0:4]) # print to confirm that darcyv did what it was supposed to (got same solution as initialization)&gt;&gt;&gt; Initial Velocity (correct): [1.e-04 1.e-04 1.e-04 1.e-04]&gt;&gt;&gt; Final Velocity: [1.e-04 1.e-04 1.e-04 1.e-04]</code></pre></div></div><p>The <code class=\"language-python\">darcyv</code> method as it is coded looks complicated but it's pretty simple mathematically. The changes made from just applying Darcy's law from the previous post (-K/mu*dP/dx) directly allow it to handle nonhomogeneous porous media and meshes of varying element size, which we might want to do later.</p><h3 id=\"matplotlib-output\">Matplotlib Output</h3><p>We’ve already gone over outputting results to data. What if you just want some quick results to confirm that everything makes sense? With 1D data, creating line plots will give us faster results. To let us know whether everything went well.</p><p>The class formation format we’ve used so far has been somewhat cumbersome due to all the parameters. Now, I just want to collect the solution to be output to an object that I can pass to a plotting function. To make the solution object, I can use metaprogramming with the type function:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>data_sol = type('sol', (object,), {})() # empty object (metaprogramming)data_sol.Np = 3 # Data at nodes: x p, K, mudata_sol.Nx = base_mesh.Nxdata_sol.varnamex = 'x (m)'data_sol.varname = ['p (Pa)', 'K ($m^2$)', '\\u03BC (Pa*s)']data_sol.x = base_mesh.xdata_sol.var = np.zeros((data_sol.Nx,data_sol.Np))data_sol.var = np.concatenate((fl1.p.reshape(data_sol.Nx,1)                               ,pm1.K.reshape(data_sol.Nx,1)                               ,fl1.mu.reshape(data_sol.Nx,1))                              ,axis=1)</code></pre></div></div><p>Here, I've created a new sol object data_sol that is initially empty. I’ve then filled it with the data I need to output and visualize, namely the pressure, permeability, and viscosity which are at the nodes. I want the velocity too but I need a different object to handle the variables calculated at the face. Corresponding code is in the Github repo for this. For now, let's focus on the plot. I can pass this sol object to a function that knows how to read it and create plots:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>def plot_out(data): # plotting function, takes in data object of specific form and prints plots    N_param = data.Np    N = data.Nx    fig, ax = plt.subplots(N_param,1,figsize=(4,5))        for i in range(0,N_param):        ax[i].plot(data.x, data.var[0:,i], color = 'black',linewidth=0.5)        ax[i].set_xlabel(data.varnamex,fontsize=12)         ax[i].set_ylabel(data.varname[i],fontsize=12)    fig.tight_layout()    plt.show()  ....plot_out(data_sol) # call the plotting output</code></pre></div></div><p><img src=\"../../../assets/images/node_data_sol.png\" alt=\"Multi-plot of the face data.\" title=\"Pressure, permeability, and viscosity vs. x.\" /></p><p>Now that we can output text and figures to check our results, we can use more sophisticated numerical methods to get solutions to more complicated problem while debugging more efficiently.</p>",
            "url": "tim-munuhe.github.io/2021/05/14/mesh-fluidpm-plot",
            
            
            
            
            
            "date_published": "2021-05-14T00:00:00-04:00",
            "date_modified": "2021-05-14T00:00:00-04:00",
            
                "author":  {
                "name": "Timothy W. Munuhe, Ph.D.",
                "url": "tim-munuhe.gitub.io",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "tim-munuhe.github.io/2021/05/01/csv-read-parameters",
            "title": "Basic Python with Darcy's Law - User-Defined Parameters",
            "summary": "Read parameters for Darcy's Law from a CSV file.",
            "content_text": "In the previous blog post, I introduced some object-oriented Python by creating a parameter class that initialized a solution to Darcy's law for some default fluid and porous medium. So, just by creating the case, we were done. Now, we want to feed our own properties into Darcy's Law.Let's start with the (easier) parameter problem: we can feed in our own fluid and porous medium properties by adding to the instantiation’s input. Currently, we just have (self) for the initialization. Let's add the length of the porous medium:class case_param():     def __init__(self,L):         self.dim = 1 # dimensions         self.x0 = 0.0 # inlet position         self.xL = self.x0 + L # outlet         fluid_name = 'Water'         mu = 0.001         u0 = 0.0         p0 = 0.0 # inlet pressure         pL = -100.0 # outlet         self.fl = {'Name': fluid_name, 'mu': mu, 'u0': u0, 'p0': p0, 'pL': pL}         pm_name = 'Sand'         K = 1.0E-9         eps = 0.15         self.pm = {'Name': pm_name, 'K':K, 'eps':eps} &gt;br&gt;         self.fl['u0'] = -K/mu*(pL-p0)/(self.xL-self.x0)  When we create the case_param object, we need to give the length in the parentheses, like so:base = case_param(1.0)Then, when we call the case's outlet location, we get our length:print(base.xL) &gt;&gt;&gt; 9.999999999999999e-05   which gives us the same answer as the first blog post:print(base.fl['u0'])  &gt;&gt;&gt; 9.999999999999999e-05   We could keep going this way but we have at least 8 parameters for our case that we'd want to vary: the fluid name, viscosity, inlet and outlet pressure, porous medium name, permeability, porosity, and the length of the domain. Instead, we can use text files or CSV files with specified formats to feed in the case parameters, allowing a more streamlined multi-case process. Let's use CSV: we can create it in Excel and it’s use in Python for Data Science means there will be resources for troublshooting later (;-)).First, import the CSV package:import csv   Next, let’s create our CSV case file using Excel:            case_name      fluid      p0      pL      mu      porous_medium      length      K      eps                  base      water      0.000      -100.000      0.001      sand      1.000      1.00E-09      0.150              long      water      0.000      -100.000      0.001      sand      2.000      1.00E-09      0.150              press      water      100.000      -100.000      0.001      sand      1.000      1.00E-09      0.150              powder      water      0.000      -100.000      0.001      powder      1.000      1.00E-11      0.300              oil      oil      0.000      -100.000      0.060      sane      1.000      1.00E-09      0.150      We can use the csv.reader function and skip the first line to create individual case parameter lists, or, we can use the csv.DictReader function to construct individual case dictionaries:with open('casefile.csv',newline='') as casefile:     casereader = csv.DictReader(casefile)     i = 0     caselist = {}     for row in casereader:            caselist[i] = row         print(row['case_name'], row['fluid'], row['mu']) # check that code works as expected         i += 1 &gt;&gt;&gt; base water 0.001 &gt;&gt;&gt; long water 0.001 &gt;&gt;&gt; press water 0.001 &gt;&gt;&gt; powder water 0.001 &gt;&gt;&gt; oil oil 0.060  DictReader uses the first row of the CSV file as the keys and the subsequent row values are the dictionary entries. The only problem is that all entries are read as strings, which must convert the number variables to floats in the &lt;pre&gt;case_param &lt;/pre&gt; instantiation:class case_param():     def __init__(self,param):         self.name = param['case_name'] # now the name is given inside the case, not as the case's actual name         self.dim = 1 # dimensions         self.x0 = 0.0 # inlet position         self.xL = self.x0 + float(param['length']) # outlet         fluid_name = param['fluid']         mu = float(param['mu'])         u0 = 0.0         p0 = float(param['p0']) # inlet pressure         pL = float(param['pL']) # outlet         self.fl = {'Name': fluid_name, 'mu': mu, 'u0': u0, 'p0': p0, 'pL': pL}         pm_name = param['porous_medium']          K = float(param['K'])         eps = float(param['eps'])         self.pm = {'Name': pm_name, 'K':K, 'eps':eps}          self.fl['u0'] = -K/mu*(pL-p0)/(self.xL-self.x0)  We can initialize the original base case and the oil case and compare the velocities: base = case_param(caselist[0])  oil = case_param(caselist[4])  print(base.fl['u0']  &gt;&gt;&gt; 9.999999999999999e-05  print(oil.fl['u0']  &gt;&gt;&gt; 1.6666666666666667e-06  We can see that the viscous oil slows down the flow, as expected. We haven’t changed the Darcy's Law calculation so we know, at least, that the code is reading the CSV file correctly and initializing the case properly.The next step is to see what is going on between the inlet and outlet, specifically with the pressure.",
            "content_html": "<p>In the previous blog post, I introduced some object-oriented Python by creating a parameter class that initialized a solution to Darcy's law for some default fluid and porous medium. So, just by creating the case, we were done. Now, we want to feed our own properties into Darcy's Law.</p><p>Let's start with the (easier) parameter problem: we can feed in our own fluid and porous medium properties by adding to the instantiation’s input. Currently, we just have <code class=\"language-python\">(self)</code> for the initialization. Let's add the length of the porous medium:</p><pre><code class=\"language-python\">class case_param(): <br />    def __init__(self,L): <br />        self.dim = 1 # dimensions <br />        self.x0 = 0.0 # inlet position <br />        self.xL = self.x0 + L # outlet <br />        fluid_name = 'Water' <br />        mu = 0.001 <br />        u0 = 0.0 <br />        p0 = 0.0 # inlet pressure <br />        pL = -100.0 # outlet <br />        self.fl = {'Name': fluid_name, 'mu': mu, 'u0': u0, 'p0': p0, 'pL': pL} <br />        pm_name = 'Sand' <br />        K = 1.0E-9 <br />        eps = 0.15 <br />        self.pm = {'Name': pm_name, 'K':K, 'eps':eps} &gt;br&gt;         self.fl['u0'] = -K/mu*(pL-p0)/(self.xL-self.x0) </code> </pre><p>When we create the <code class=\"language-python\">case_param</code> object, we need to give the length in the parentheses, like so:</p><pre><code class=\"language-python\">base = case_param(1.0)</code></pre><p>Then, when we call the case's outlet location, we get our length:</p><pre><code class=\"language-python\">print(base.xL) <br />&gt;&gt;&gt; 9.999999999999999e-05  </code> </pre><p>which gives us the same answer as the first blog post:</p><pre><code class=\"language-python\">print(base.fl['u0']) <br /> &gt;&gt;&gt; 9.999999999999999e-05  </code> </pre><p>We could keep going this way but we have at least 8 parameters for our case that we'd want to vary: the fluid name, viscosity, inlet and outlet pressure, porous medium name, permeability, porosity, and the length of the domain. Instead, we can use text files or CSV files with specified formats to feed in the case parameters, allowing a more streamlined multi-case process. Let's use CSV: we can create it in Excel and it’s use in Python for Data Science means there will be resources for troublshooting later (;-)).</p><p>First, import the <code class=\"language-python\">CSV</code> package:</p><pre><code class=\"language-python\">import csv  </code> </pre><p>Next, let’s create our CSV case file using Excel:</p><table>  <thead>    <tr>      <th>case_name</th>      <th>fluid</th>      <th>p0</th>      <th>pL</th>      <th>mu</th>      <th>porous_medium</th>      <th>length</th>      <th>K</th>      <th>eps</th>    </tr>  </thead>  <tbody>    <tr>      <td>base</td>      <td>water</td>      <td>0.000</td>      <td>-100.000</td>      <td>0.001</td>      <td>sand</td>      <td>1.000</td>      <td>1.00E-09</td>      <td>0.150</td>    </tr>    <tr>      <td>long</td>      <td>water</td>      <td>0.000</td>      <td>-100.000</td>      <td>0.001</td>      <td>sand</td>      <td>2.000</td>      <td>1.00E-09</td>      <td>0.150</td>    </tr>    <tr>      <td>press</td>      <td>water</td>      <td>100.000</td>      <td>-100.000</td>      <td>0.001</td>      <td>sand</td>      <td>1.000</td>      <td>1.00E-09</td>      <td>0.150</td>    </tr>    <tr>      <td>powder</td>      <td>water</td>      <td>0.000</td>      <td>-100.000</td>      <td>0.001</td>      <td>powder</td>      <td>1.000</td>      <td>1.00E-11</td>      <td>0.300</td>    </tr>    <tr>      <td>oil</td>      <td>oil</td>      <td>0.000</td>      <td>-100.000</td>      <td>0.060</td>      <td>sane</td>      <td>1.000</td>      <td>1.00E-09</td>      <td>0.150</td>    </tr>  </tbody></table><p>We can use the <code class=\"language-python\">csv.reader</code> function and skip the first line to create individual case parameter lists, or, we can use the <code class=\"language-python\">csv.DictReader</code> function to construct individual case dictionaries:</p><pre><code class=\"language-python\">with open('casefile.csv',newline='') as casefile: <br />    casereader = csv.DictReader(casefile) <br />    i = 0 <br />    caselist = {} <br />    for row in casereader:    <br />        caselist[i] = row <br />        print(row['case_name'], row['fluid'], row['mu']) # check that code works as expected <br />        i += 1 <br />&gt;&gt;&gt; base water 0.001 <br />&gt;&gt;&gt; long water 0.001 <br />&gt;&gt;&gt; press water 0.001 <br />&gt;&gt;&gt; powder water 0.001 <br />&gt;&gt;&gt; oil oil 0.060 </code> </pre><p>DictReader uses the first row of the CSV file as the keys and the subsequent row values are the dictionary entries. The only problem is that all entries are read as strings, which must convert the number variables to floats in the &lt;pre&gt;<code class=\"language-python\">case_param</code> &lt;/pre&gt; instantiation:</p><pre><code class=\"language-python\">class case_param(): <br />    def __init__(self,param): <br />        self.name = param['case_name'] # now the name is given inside the case, not as the case's actual name <br />        self.dim = 1 # dimensions <br />        self.x0 = 0.0 # inlet position <br />        self.xL = self.x0 + float(param['length']) # outlet <br />        fluid_name = param['fluid'] <br />        mu = float(param['mu']) <br />        u0 = 0.0 <br />        p0 = float(param['p0']) # inlet pressure <br />        pL = float(param['pL']) # outlet <br />        self.fl = {'Name': fluid_name, 'mu': mu, 'u0': u0, 'p0': p0, 'pL': pL} <br />        pm_name = param['porous_medium']  <br />        K = float(param['K']) <br />        eps = float(param['eps']) <br />        self.pm = {'Name': pm_name, 'K':K, 'eps':eps} <br />         self.fl['u0'] = -K/mu*(pL-p0)/(self.xL-self.x0) </code> </pre><p>We can initialize the original base case and the oil case and compare the velocities:</p><pre><code class=\"language-python\"> base = case_param(caselist[0]) <br /> oil = case_param(caselist[4]) <br /> print(base.fl['u0'] <br /> &gt;&gt;&gt; 9.999999999999999e-05 <br /> print(oil.fl['u0'] <br /> &gt;&gt;&gt; 1.6666666666666667e-06 </code> </pre><p>We can see that the viscous oil slows down the flow, as expected. We haven’t changed the Darcy's Law calculation so we know, at least, that the code is reading the CSV file correctly and initializing the case properly.</p><p>The next step is to see what is going on between the inlet and outlet, specifically with the pressure.</p>",
            "url": "tim-munuhe.github.io/2021/05/01/csv-read-parameters",
            
            
            
            
            
            "date_published": "2021-05-01T00:00:00-04:00",
            "date_modified": "2021-05-01T00:00:00-04:00",
            
                "author":  {
                "name": "Timothy W. Munuhe, Ph.D.",
                "url": "tim-munuhe.gitub.io",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "tim-munuhe.github.io/2021/04/18/darcys-law",
            "title": "Basic Python with Darcy's Law - Introduction",
            "summary": "Let's begin our Python journey by calculating porous fluid flow.",
            "content_text": "Darcy's law is an equation used to calculate fluid flow through a porous medium under a pressure gradient. It’s also a useful test problem to explore scientific computing with Python from a basic to intermediate level.Darcy's Law can be written as:where  is the superficial flow velocity,  is the hydraulic permeability of the porous medium,  is the viscosity of the liquid, and  is the pressure distribution. All three variables can vary over space. If the problem considered is 2D or 3D, then Darcy's Law becomes a partial differential equation (PDE).PDEs represent a myriad of phenomena mathematically, including heat transfer, electro-magnetism and the price of European options. You can find better discussions elsewhere but some prototypical equations to learn about are Laplace’s equation, Poisson’s equation, the Heat equation, and the Wave equation.Problem SetupLet's say we have a pipe filled with sand. A fluid can flow in the spaces between the individual grains of sand, termed the pores. Depending on how big or small or well-packed the sand grains are, it's easier or harder for the fluid to flow through the pipe. This is represented by . The fluid's viscosity also affects how easily it can flow through the pores (maple syrup? or water? or air?).Basically, the porous medium and fluid flow properties are constant. Let's also assume that the pipe is long enough relative to its diameter that we can assume that pressure only varies significantly along its axis. Then, we can treat this as a 1D problem:So now we have an ordinary differential equation, or ODE. To complete the description of the problem we need 2 boundary conditions. Let's give two boundary conditions:Let's give some properties so we can move on:            Property      Value                                                                                                              Enough Physics. Let's Code!With our current assumptions, the superficial velocity at every point within the pipe is:Then we can solve it quite easily with: K = 1.0E-9 # permeability  mu = 0.001 # viscosity  P_0 = 0.0 # inlet  P_L = -100.0 #outlet  L = 1.0 # pipe length  u = -K/mu*(P_L-P_0)/L  print(u)  &gt;&gt;&gt; 9.999999999999999e-05   Simple, but now I can change the variables and get the velocity immediately. I can even add a bit of extra code to output results and create a sort of solution space examining the effects of different variables. However, the assumptions made to get here are pretty restrictive. What if we want to check the pressure along the pipe? What if the sand is not homogeneous? What if the viscosity of the fluid changes because of temperature? We need a more robust solution.Some basic object-oriented programmingAdmittedly, I'm still learning object-oriented programming so all I can do is write how I understand my code within the paradigm. That being said, the code will work, so take solace in that.I want a more robust code that can take user input and tell the rest of the code how to run. So, I'm going to create a case object. I create a case class:class case_param():     def __init__(self):         self.dim = 1 # dimensions         self.x0 = 0.0 # inlet position         self.xL = 1.0 # outlet         fluid_name = 'Water'         mu = 0.001         u0 = 0.0         p0 = 0.0 # inlet pressure         pL = -100.0 # outlet         self.fl = {'Name': fluid_name, 'mu': mu, 'u0': u0, 'p0': p0, 'pL': pL}         pm_name = 'Sand'         K = 1.0E-9         eps = 0.15         self.pm = {'Name': pm_name, 'K':K, 'eps':eps}  This class, in short, defines case objects through common variables: number of dimensions, inlet and outlet position, and the fluid and porous medium used and their properties. The fluid and porous medium are both represented thorugh dictionaries which other objects or methods can refer to. Let's use it:base = case_param() base.u0 = -base.pm['K']/base.fl['mu']*(base.fl['pL']-base.fl['p0'])/(base.xL-base.x0) print(base.u0) &gt;&gt;&gt; 9.999999999999999e-05  So, we've got the same result as the previous, simpler code. We’ve also created a case object that the other to-be-created code can use. For now, let me compress the code by initializing the superficial velocity in the instantiation (__init__ method):class case_param():     def __init__(self):         self.dim = 1 # dimensions         self.x0 = 0.0 # inlet position         self.xL = 1.0 # outlet         fluid_name = 'Water'         mu = 0.001         u0 = 0.0         p0 = 0.0 # inlet pressure         pL = -100.0 # outlet         self.fl = {'Name': fluid_name, 'mu': mu, 'u0': u0, 'p0': p0, 'pL': pL}         pm_name = 'Sand'         K = 1.0E-9         eps = 0.15         self.pm = {'Name': pm_name, 'K':K, 'eps':eps}         self.fl['u0'] = -K/mu*(pL-p0)/(self.xL-self.x0) base = case_param() print(base.fl['u0']) &gt;&gt;&gt; 9.999999999999999e-05  Later, I'll be able to pass this to a mesh object and Darcy’s law method to create a solution that I can plot and output to CSV.",
            "content_html": "<p>Darcy's law is an equation used to calculate fluid flow through a porous medium under a pressure gradient. It’s also a useful test problem to explore scientific computing with Python from a basic to intermediate level.</p><p>Darcy's Law can be written as:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?\\vec{u}&space;=&space;-\\frac{K}{\\mu}\\nabla&space;P\" /></p><p>where <img src=\"https://latex.codecogs.com/svg.image?\\vec{u}\" alt=\"vel\" /> is the superficial flow velocity, <img src=\"https://latex.codecogs.com/svg.image?K\" alt=\"perm\" /> is the hydraulic permeability of the porous medium, <img src=\"https://latex.codecogs.com/svg.image?\\mu\" alt=\"visc\" /> is the viscosity of the liquid, and <img src=\"https://latex.codecogs.com/svg.image?P\" alt=\"pres\" /> is the pressure distribution. All three variables can vary over space. If the problem considered is 2D or 3D, then Darcy's Law becomes a partial differential equation (PDE).</p><p>PDEs represent a myriad of phenomena mathematically, including heat transfer, electro-magnetism and the price of European options. You can find better discussions elsewhere but some prototypical equations to learn about are Laplace’s equation, Poisson’s equation, the Heat equation, and the Wave equation.</p><h3>Problem Setup</h3><p>Let's say we have a pipe filled with sand. A fluid can flow in the spaces between the individual grains of sand, termed the pores. Depending on how big or small or well-packed the sand grains are, it's easier or harder for the fluid to flow through the pipe. This is represented by <img src=\"https://latex.codecogs.com/svg.image?K\" alt=\"perm\" />. The fluid's viscosity also affects how easily it can flow through the pores (maple syrup? or water? or air?).</p><p>Basically, the porous medium and fluid flow properties are constant. Let's also assume that the pipe is long enough relative to its diameter that we can assume that pressure only varies significantly along its axis. Then, we can treat this as a 1D problem:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?u&space;=&space;-\\dfrac{K}{\\mu}\\dfrac{dP}{dx}\" /></p><p>So now we have an ordinary differential equation, or ODE. To complete the description of the problem we need 2 boundary conditions. Let's give two boundary conditions:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?P(x=0)&space;=&space;P_0\" /></p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?P(x=L)&space;=&space;P_L\" /></p><p>Let's give some properties so we can move on:</p><table>  <thead>    <tr>      <th style=\"text-align: center\">Property</th>      <th style=\"text-align: center\">Value</th>    </tr>  </thead>  <tbody>    <tr>      <td style=\"text-align: center\"><img src=\"https://latex.codecogs.com/svg.image?K\" alt=\"perm\" /></td>      <td style=\"text-align: center\"><img src=\"https://latex.codecogs.com/svg.image?10^{-9}\\;\\frac{m^2}{s}\" alt=\"Kval\" /></td>    </tr>    <tr>      <td style=\"text-align: center\"><img src=\"https://latex.codecogs.com/svg.image?\\mu\" alt=\"visc\" /></td>      <td style=\"text-align: center\"><img src=\"https://latex.codecogs.com/svg.image?0.001\\;Pa\\cdot&space;s\" alt=\"Kval\" /></td>    </tr>    <tr>      <td style=\"text-align: center\"><img src=\"https://latex.codecogs.com/svg.image?P_0\" alt=\"perm\" /></td>      <td style=\"text-align: center\"><img src=\"https://latex.codecogs.com/svg.image?0\\;Pa\" alt=\"Kval\" /></td>    </tr>    <tr>      <td style=\"text-align: center\"><img src=\"https://latex.codecogs.com/svg.image?P_L\" alt=\"perm\" /></td>      <td style=\"text-align: center\"><img src=\"https://latex.codecogs.com/svg.image?-100\\;Pa\" alt=\"Kval\" /></td>    </tr>    <tr>      <td style=\"text-align: center\"><img src=\"https://latex.codecogs.com/svg.image?L\" alt=\"perm\" /></td>      <td style=\"text-align: center\"><img src=\"https://latex.codecogs.com/svg.image?1\\;m\" alt=\"Kval\" /></td>    </tr>  </tbody></table><h3>Enough Physics. Let's Code!</h3><p>With our current assumptions, the superficial velocity at every point within the pipe is:</p><p align=\"center\"><img src=\"https://latex.codecogs.com/svg.image?u=-\\dfrac{K}{\\mu}\\dfrac{P_L-P_0}{L}\" /></p><p>Then we can solve it quite easily with:</p><pre><code class=\"language-python\"> K = 1.0E-9 # permeability <br /> mu = 0.001 # viscosity <br /> P_0 = 0.0 # inlet <br /> P_L = -100.0 #outlet <br /> L = 1.0 # pipe length <br /> u = -K/mu*(P_L-P_0)/L <br /> print(u) <br /> &gt;&gt;&gt; 9.999999999999999e-05  </code> </pre><p>Simple, but now I can change the variables and get the velocity immediately. I can even add a bit of extra code to output results and create a sort of solution space examining the effects of different variables. However, the assumptions made to get here are pretty restrictive. What if we want to check the pressure along the pipe? What if the sand is not homogeneous? What if the viscosity of the fluid changes because of temperature? We need a more robust solution.</p><h3>Some basic object-oriented programming</h3><p>Admittedly, I'm still learning object-oriented programming so all I can do is write how I understand my code within the paradigm. That being said, the code will work, so take solace in that.I want a more robust code that can take user input and tell the rest of the code how to run. So, I'm going to create a case object. I create a case class:</p><pre><code class=\"language-python\">class case_param(): <br />    def __init__(self): <br />        self.dim = 1 # dimensions <br />        self.x0 = 0.0 # inlet position <br />        self.xL = 1.0 # outlet <br />        fluid_name = 'Water' <br />        mu = 0.001 <br />        u0 = 0.0 <br />        p0 = 0.0 # inlet pressure <br />        pL = -100.0 # outlet <br />        self.fl = {'Name': fluid_name, 'mu': mu, 'u0': u0, 'p0': p0, 'pL': pL} <br />        pm_name = 'Sand' <br />        K = 1.0E-9 <br />        eps = 0.15 <br />        self.pm = {'Name': pm_name, 'K':K, 'eps':eps} </code> </pre><p>This class, in short, defines case objects through common variables: number of dimensions, inlet and outlet position, and the fluid and porous medium used and their properties. The fluid and porous medium are both represented thorugh dictionaries which other objects or methods can refer to. Let's use it:</p><pre><code class=\"language-python\">base = case_param() <br />base.u0 = -base.pm['K']/base.fl['mu']*(base.fl['pL']-base.fl['p0'])/(base.xL-base.x0) <br />print(base.u0) <br />&gt;&gt;&gt; 9.999999999999999e-05 </code> </pre><p>So, we've got the same result as the previous, simpler code. We’ve also created a case object that the other to-be-created code can use. For now, let me compress the code by initializing the superficial velocity in the instantiation (__init__ method):</p><pre><code class=\"language-python\">class case_param(): <br />    def __init__(self): <br />        self.dim = 1 # dimensions <br />        self.x0 = 0.0 # inlet position <br />        self.xL = 1.0 # outlet <br />        fluid_name = 'Water' <br />        mu = 0.001 <br />        u0 = 0.0 <br />        p0 = 0.0 # inlet pressure <br />        pL = -100.0 # outlet <br />        self.fl = {'Name': fluid_name, 'mu': mu, 'u0': u0, 'p0': p0, 'pL': pL} <br />        pm_name = 'Sand' <br />        K = 1.0E-9 <br />        eps = 0.15 <br />        self.pm = {'Name': pm_name, 'K':K, 'eps':eps} <br />        self.fl['u0'] = -K/mu*(pL-p0)/(self.xL-self.x0) <br /><br />base = case_param() <br />print(base.fl['u0']) <br />&gt;&gt;&gt; 9.999999999999999e-05 </code> </pre><p>Later, I'll be able to pass this to a mesh object and Darcy’s law method to create a solution that I can plot and output to CSV.</p>",
            "url": "tim-munuhe.github.io/2021/04/18/darcys-law",
            
            
            
            
            
            "date_published": "2021-04-18T00:00:00-04:00",
            "date_modified": "2021-04-18T00:00:00-04:00",
            
                "author":  {
                "name": "Timothy W. Munuhe, Ph.D.",
                "url": "tim-munuhe.gitub.io",
                "avatar": null
                }
                
            
        }
    
    ]
}