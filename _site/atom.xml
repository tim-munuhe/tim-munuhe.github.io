<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>tim-munuhe</title>
 <link href="tim-munuhe.github.io/atom.xml" rel="self"/>
 <link href="tim-munuhe.github.io/"/>
 <updated>2021-05-14T20:23:59-04:00</updated>
 <id>tim-munuhe.github.io</id>
 <author>
   <name>Timothy W. Munuhe, Ph.D.</name>
   <email>timothy.munuhe@gmail.com</email>
 </author>

 
 <entry>
   <title>Basic Python with Darcy's Law - Meshing, Basic Spatial Solutions, and Plotting Output</title>
   <link href="tim-munuhe.github.io/2021/05/14/mesh-fluidpm-plot"/>
   <updated>2021-05-14T00:00:00-04:00</updated>
   <id>tim-munuhe.github.io/2021/05/14/Mesh-FluidPM-Plot</id>
   <content type="html">&lt;p&gt;Now that we have some practice with objects in Python and Darcy’s law, we can create a program that is more expandable and useful. Since this is a physical problem, we need to consider space in our code. So, we need to add a mesh to represent the porous medium and the fluid inside its pores. We also need to output data as plots for immediate review and in a way that other programs can read.&lt;/p&gt;

&lt;p&gt;More classes and objects can get unwieldy, so let's develop a sketch of how the program is going to work overall so we can code effectively. First, a text description: the user (you, or me) is going to create a case file that the csv.Dictreader function will read into Python listing case parameters.  A case object will be instantiated using that data just read. This is as far as we got in the previous post. Now, we can create a mesh (object) representing the space filled with the fluid (object) and solid material/matrix (object). All three objects' parameters will be determined by that parameters specified in the case file. Since the fluid is the only one flowing, Darcy's Law will be called on it to calculate the pressure and flow velocity at the locations specified by the mesh. Lastly, relevant properties will be output to a file that the user can plot or analyze.&lt;/p&gt;

&lt;p&gt;Simple, right? Remember, one step at a time.&lt;/p&gt;

&lt;h3 id=&quot;the-mesh&quot;&gt;The Mesh&lt;/h3&gt;

&lt;p&gt;The mesh can represent a 1D, 2D, or 3D space. Assume we have a cylindrical pipe filled with sand and water. Depending on its width, diameter, and how homogeneous the sand is, we might want to consider it in 3D or 2D. If we also assume the pipe is very long relative to its diameter, we can simplify the problem to 1D. A 1D mesh is essentially a line with points along it while the 2D and 3D spaces can be divided into a variety of 2D and 3D shapes (squares and cubes being particularly common). So, each element of the 1D mesh represents a slice of the pipe.&lt;/p&gt;

&lt;p&gt;I'll be using finite difference method for the majority of the blog posts. There's more math here than I care to dig into but I recommend reading Patankar &amp;amp; Spalding’s 1972 paper titled “A Calculation Procedure for Heat, Mass, and Momentum Transfer”. In short, from Darcy’s Law, the pressure gradient is used to calculate the velocity. So, the velocity and pressure are more accurately considered at offset locations, for example on a staggered mesh. That is, where you calculate the velocity is offset from where you calculate the pressures. So, you use the pressures at two adjacent cells to calculate the (volume-averaged) velocity at the face between those cells. You can do this to get the velocities at the interior faces. At the inlet and outlet, the inlet pressure and velocity are collocated which may affect the accuracy. That is not important for the current code but, for better-than-1st-order accuracy, we'd need to derive a better approximation for the pressure gradients there. In any case, &lt;a href=&quot;https://www.cfd-online.com/Wiki/Staggered_grid&quot;&gt;CFD-Online has a pretty short article about the staggered grid issue&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Back to the OOP: we create a mesh class where each mesh object has a name, shape, density, and specified node (x), interior face (xc), and boundary locations (also xc):&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class mesh(): # mesh class
    def __init__(self,case): # Take in the case info for certain params
        dim = 1 # case.dim
        if (dim == 1):
            self.Nx = int((case.xL - case.x0)/case.dx + 2.0)
        
            # Face locations
            self.xc = np.ones(self.Nx)*case.x0# Initialize mesh
            self.xc[self.Nx-1] = case.xL # Outward boundary
            for i in range(2,self.Nx-1): 
                self.xc[i] = (i-1)*case.dx # Cell Face Locations

            # Node locations
            self.x = np.copy(self.xc) # Initialize mesh
            for i in range(0,self.Nx-1):
                self.x[i] = (self.xc[i+1] + self.xc[i])/2 # Cell Node Locations: halfway between faces
            self.x[self.Nx-1] = np.copy(self.xc[self.Nx-1]) # Outward boundary
    
    def output(self,fname): # output mesh
        with open(fname,'w', newline='') as csvfile:
            mesh_write = csv.writer(csvfile,dialect = 'excel', delimiter = '\t') # writer object
            mesh_write.writerow(['i', 'x', 'xc']) # header row
            for i in range(0,self.Nx):
                mesh_write.writerow([i+1,self.x[i],self.xc[i]]) # actual data rows
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The mesh consists of nodes and faces: the number of nodes is the number of slices the make the pipe plus 2. Why the plus 2? There are two additional nodes at the inlet and outlet. There is one less face but, to keep the indices and array lengths the same, the inlet face is duplicated. This helps with coding and that first face can be ignored for the most part. 
The mesh requires a case object for its instantiation, so we create the mesh object using &lt;code class=&quot;language-python&quot;&gt;base_mesh = mesh(base)&lt;/code&gt;. Let’s ask for some information, just to make sure everything ran smoothly:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print('Node Locations w/ inlet:', base_mesh.x[0:5]) # check inlet location and spacing
print('Nx:', base_mesh.Nx) # check number of elements
print('Outlet Location:', base_mesh.x[base_mesh.Nx-1])
print('Face Locations:', base_mesh.xc[0:5]) 
&amp;gt;&amp;gt;&amp;gt; Node Locations w/ inlet: [0.   0.01 0.03 0.05 0.07]
&amp;gt;&amp;gt;&amp;gt; Nx: 52
&amp;gt;&amp;gt;&amp;gt; Outlet Location: 1.0
&amp;gt;&amp;gt;&amp;gt; Face Locations: [0.   0.   0.02 0.04 0.06]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The number of elements is correct, the inlet face is duplicated, and the spacing for the interior node locations is correct. For the calculations to follow, we just have to remember the offset between the node and face indices for our accuracy. Now we can output this to a file that another program can use, maybe for visualization, by calling the output method that's also in the mesh class: &lt;code class=&quot;language-python&quot;&gt;base_mesh.output('base_mesh.dat')&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If everything works, the first six lines of your &lt;a href=&quot;URL to file&quot;&gt;text file&lt;/a&gt; will be:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;i	x	xc
1	0.0	0.0
2	0.01	0.0
3	0.03	0.02
4	0.05	0.04
5	0.07	0.06
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you’re using excel, you can output a csv file: go to the Data tab and do text-to-columns on all the rows with a tab delimiter to get it formatted.&lt;/p&gt;

&lt;h3 id=&quot;applying-darcys-law-as-a-method-to-a-fluid-object&quot;&gt;Applying Darcy's Law as a Method to a Fluid Object&lt;/h3&gt;

&lt;p&gt;Because the porous medium and fluid occupy the space of the mesh, they need to have some of the same properties as the mesh, namely the shape and spatial positions of the mesh. Then, the pressure at &lt;code class=&quot;language-python&quot;&gt;p[i]&lt;/code&gt; is the pressure at the location &lt;code class=&quot;language-python&quot;&gt;x[i]&lt;/code&gt;. Apart from the size and shape, the fluid and porous medium share a pressure and have their own properties as outlined in Darcy's Law. Both have their own names and volume fractions. The fluid will have a viscosity and velocity and the porous medium will have a permeability:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class fluid(): # fluid class, can create multiple fluid objects for multiphase flow or other studies
    def __init__(self,mesh,fluid_prop):
        self.name = fluid_prop['Name']
        # Initialize variables
        self.p = np.ones(mesh.Nx)*fluid_prop['p0'] # Pressure
        self.p[mesh.Nx-1] = fluid_prop['pL'] # Pressure boundary at x = L
        self.u = np.ones(mesh.Nx)*fluid_prop['u0'] # Velocity: Staggered mesh so velocity at faces
        self.mu = np.ones(mesh.Nx)*fluid_prop['mu'] # Viscosity
    def p_lin(self,mesh):
        N = mesh.Nx
        L = mesh.x[N-1]
        L0 = mesh.x[0]
        for i in range(1,N):
            self.p[i] = (self.p[N-1]-self.p[0])/(L-L0)*mesh.x[i]
    def darcyv(self,mesh,pm):
        N = mesh.Nx
        self.u[0] = -pm.K[0]/self.mu[0]*(self.p[1]-self.p[0])/(mesh.x[1]-mesh.x[0]) # inlet
        self.u[1] = self.u[0] # same location
        for i in range(2,N-1): # interior faces
            Ai = pm.K[i-1]/self.mu[i-1]/(mesh.xc[i]-mesh.x[i-1])
            Ai1 = pm.K[i]/self.mu[i]/(mesh.x[i]-mesh.xc[i])
            self.u[i] = -Ai*Ai1/(Ai+Ai1)*(self.p[i]-self.p[i-1])
        self.u[N-1] = -pm.K[N-1]/self.mu[N-1]*(self.p[N-1]-self.p[N-2])/(mesh.x[N-1]-mesh.x[N-2]) # outlet

class por_med(): # porous medium class, for parametric studies or composite porous media
    def __init__(self,mesh,pm_prop):
        self.name = pm_prop
        # Initialize Variables
        self.K = np.ones(mesh.Nx)*pm_prop['K'] # Permeability
        self.eps = np.ones(mesh.Nx)*pm_prop['eps'] # Porosity
.
.
.
fl1 = fluid(base_mesh,base.fl) # fluid object, determined by mesh and case's fluid properties
pm1 = por_med(base_mesh,base.pm) # porous medium object, determined by mesh and case's porous medium properties
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With the fluid and porous medium objects created, we can find the pressures and flow velocities within the domain at the points specified by the mesh. While we can do something similar to the direct calculation in in the first blog post, let’s create methods so that the functions are tied to the specific objects. This connects the equations to the specific parts of the problem more directly.&lt;/p&gt;

&lt;p&gt;Since the porous medium is homogeneous, we can assume that the pressure distribution in the porous medium is linear, with the boundary conditions in the case corresponding to the inlet and outlet pressures. Then, we can code a very simple pressure calculation method for the fluid below the instantiation, represented by the &lt;code class=&quot;language-python&quot;&gt;p_lin(mesh)&lt;/code&gt; method in the fluid class above:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print('Initial Pressure:',fl1.p[0:4])
fl1.p_lin(base_mesh)
print('Linear Pressure:',fl1.p[0:4])
&amp;gt;&amp;gt;&amp;gt; Initial Pressure: [0. 0. 0. 0.]
&amp;gt;&amp;gt;&amp;gt; Linear Pressure: [ 0. -1. -3. -5.]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;At the faces (represented by &lt;code class=&quot;language-python&quot;&gt;xc&lt;/code&gt;) we can then calculate the velocities using the Darcy’s Law method also in the fluid class:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print('Initial Velocity (correct):',fl1.u[0:4]) # velocity from initialization
fl1.u = np.zeros(base_mesh.Nx) # zero out velocity 
fl1.darcyv(base_mesh,pm1) # use darcyv method
print('Final Velocity:',fl1.u[0:4]) # print to confirm that darcyv did what it was supposed to (got same solution as initialization)
&amp;gt;&amp;gt;&amp;gt; Initial Velocity (correct): [1.e-04 1.e-04 1.e-04 1.e-04]
&amp;gt;&amp;gt;&amp;gt; Final Velocity: [1.e-04 1.e-04 1.e-04 1.e-04]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;language-python&quot;&gt;darcyv&lt;/code&gt; method as it is coded looks complicated but it's pretty simple mathematically. The changes made from just applying Darcy's law from the previous post (-K/mu*dP/dx) directly allow it to handle nonhomogeneous porous media and meshes of varying element size, which we might want to do later.&lt;/p&gt;

&lt;h3 id=&quot;matplotlib-output&quot;&gt;Matplotlib Output&lt;/h3&gt;

&lt;p&gt;We’ve already gone over outputting results to data. What if you just want some quick results to confirm that everything makes sense? With 1D data, creating line plots will give us faster results. To let us know whether everything went well.&lt;/p&gt;

&lt;p&gt;The class formation format we’ve used so far has been somewhat cumbersome due to all the parameters. Now, I just want to collect the solution to be output to an object that I can pass to a plotting function. To make the solution object, I can use metaprogramming with the type function:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;data_sol = type('sol', (object,), {})() # empty object (metaprogramming)

data_sol.Np = 3 # Data at nodes: x p, K, mu
data_sol.Nx = base_mesh.Nx
data_sol.varnamex = 'x (m)'
data_sol.varname = ['p (Pa)', 'K ($m^2$)', '\u03BC (Pa*s)']
data_sol.x = base_mesh.x
data_sol.var = np.zeros((data_sol.Nx,data_sol.Np))
data_sol.var = np.concatenate((fl1.p.reshape(data_sol.Nx,1)
                               ,pm1.K.reshape(data_sol.Nx,1)
                               ,fl1.mu.reshape(data_sol.Nx,1))
                              ,axis=1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here, I've created a new sol object data_sol that is initially empty. I’ve then filled it with the data I need to output and visualize, namely the pressure, permeability, and viscosity which are at the nodes. I want the velocity too but I need a different object to handle the variables calculated at the face. Corresponding code is in the Github repo for this. For now, let's focus on the plot. I can pass this sol object to a function that knows how to read it and create plots:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def plot_out(data): # plotting function, takes in data object of specific form and prints plots
    N_param = data.Np
    N = data.Nx
    fig, ax = plt.subplots(N_param,1,figsize=(4,5))    
    for i in range(0,N_param):
        ax[i].plot(data.x, data.var[0:,i], color = 'black',linewidth=0.5)
        ax[i].set_xlabel(data.varnamex,fontsize=12) 
        ax[i].set_ylabel(data.varname[i],fontsize=12)
    fig.tight_layout()
    plt.show()  
.
.
.
.
plot_out(data_sol) # call the plotting output
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/images/node_data_sol.png&quot; alt=&quot;Multi-plot of the face data.&quot; title=&quot;Pressure, permeability, and viscosity vs. x.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now that we can output text and figures to check our results, we can use more sophisticated numerical methods to get solutions to more complicated problem while debugging more efficiently.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Basic Python with Darcy's Law - User-Defined Parameters</title>
   <link href="tim-munuhe.github.io/2021/05/01/csv-read-parameters"/>
   <updated>2021-05-01T00:00:00-04:00</updated>
   <id>tim-munuhe.github.io/2021/05/01/CSV-Read-Parameters</id>
   <content type="html">&lt;p&gt;In the previous blog post, I introduced some object-oriented Python by creating a parameter class that initialized a solution to Darcy's law for some default fluid and porous medium. So, just by creating the case, we were done. Now, we want to feed our own properties into Darcy's Law.&lt;/p&gt;

&lt;p&gt;Let's start with the (easier) parameter problem: we can feed in our own fluid and porous medium properties by adding to the instantiation’s input. Currently, we just have &lt;code class=&quot;language-python&quot;&gt;(self)&lt;/code&gt; for the initialization. Let's add the length of the porous medium:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class case_param(): &lt;br /&gt;    def __init__(self,L): &lt;br /&gt;        self.dim = 1 # dimensions &lt;br /&gt;        self.x0 = 0.0 # inlet position &lt;br /&gt;        self.xL = self.x0 + L # outlet &lt;br /&gt;        fluid_name = 'Water' &lt;br /&gt;        mu = 0.001 &lt;br /&gt;        u0 = 0.0 &lt;br /&gt;        p0 = 0.0 # inlet pressure &lt;br /&gt;        pL = -100.0 # outlet &lt;br /&gt;        self.fl = {'Name': fluid_name, 'mu': mu, 'u0': u0, 'p0': p0, 'pL': pL} &lt;br /&gt;        pm_name = 'Sand' &lt;br /&gt;        K = 1.0E-9 &lt;br /&gt;        eps = 0.15 &lt;br /&gt;        self.pm = {'Name': pm_name, 'K':K, 'eps':eps} &amp;gt;br&amp;gt;         self.fl['u0'] = -K/mu*(pL-p0)/(self.xL-self.x0) &lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;When we create the &lt;code class=&quot;language-python&quot;&gt;case_param&lt;/code&gt; object, we need to give the length in the parentheses, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;base = case_param(1.0)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, when we call the case's outlet location, we get our length:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;print(base.xL) &lt;br /&gt;&amp;gt;&amp;gt;&amp;gt; 9.999999999999999e-05  &lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;which gives us the same answer as the first blog post:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;print(base.fl['u0']) &lt;br /&gt; &amp;gt;&amp;gt;&amp;gt; 9.999999999999999e-05  &lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;We could keep going this way but we have at least 8 parameters for our case that we'd want to vary: the fluid name, viscosity, inlet and outlet pressure, porous medium name, permeability, porosity, and the length of the domain. Instead, we can use text files or CSV files with specified formats to feed in the case parameters, allowing a more streamlined multi-case process. Let's use CSV: we can create it in Excel and it’s use in Python for Data Science means there will be resources for troublshooting later (;-)).&lt;/p&gt;

&lt;p&gt;First, import the &lt;code class=&quot;language-python&quot;&gt;CSV&lt;/code&gt; package:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import csv  &lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;Next, let’s create our CSV case file using Excel:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;case_name&lt;/th&gt;
      &lt;th&gt;fluid&lt;/th&gt;
      &lt;th&gt;p0&lt;/th&gt;
      &lt;th&gt;pL&lt;/th&gt;
      &lt;th&gt;mu&lt;/th&gt;
      &lt;th&gt;porous_medium&lt;/th&gt;
      &lt;th&gt;length&lt;/th&gt;
      &lt;th&gt;K&lt;/th&gt;
      &lt;th&gt;eps&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;base&lt;/td&gt;
      &lt;td&gt;water&lt;/td&gt;
      &lt;td&gt;0.000&lt;/td&gt;
      &lt;td&gt;-100.000&lt;/td&gt;
      &lt;td&gt;0.001&lt;/td&gt;
      &lt;td&gt;sand&lt;/td&gt;
      &lt;td&gt;1.000&lt;/td&gt;
      &lt;td&gt;1.00E-09&lt;/td&gt;
      &lt;td&gt;0.150&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;long&lt;/td&gt;
      &lt;td&gt;water&lt;/td&gt;
      &lt;td&gt;0.000&lt;/td&gt;
      &lt;td&gt;-100.000&lt;/td&gt;
      &lt;td&gt;0.001&lt;/td&gt;
      &lt;td&gt;sand&lt;/td&gt;
      &lt;td&gt;2.000&lt;/td&gt;
      &lt;td&gt;1.00E-09&lt;/td&gt;
      &lt;td&gt;0.150&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;press&lt;/td&gt;
      &lt;td&gt;water&lt;/td&gt;
      &lt;td&gt;100.000&lt;/td&gt;
      &lt;td&gt;-100.000&lt;/td&gt;
      &lt;td&gt;0.001&lt;/td&gt;
      &lt;td&gt;sand&lt;/td&gt;
      &lt;td&gt;1.000&lt;/td&gt;
      &lt;td&gt;1.00E-09&lt;/td&gt;
      &lt;td&gt;0.150&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;powder&lt;/td&gt;
      &lt;td&gt;water&lt;/td&gt;
      &lt;td&gt;0.000&lt;/td&gt;
      &lt;td&gt;-100.000&lt;/td&gt;
      &lt;td&gt;0.001&lt;/td&gt;
      &lt;td&gt;powder&lt;/td&gt;
      &lt;td&gt;1.000&lt;/td&gt;
      &lt;td&gt;1.00E-11&lt;/td&gt;
      &lt;td&gt;0.300&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;oil&lt;/td&gt;
      &lt;td&gt;oil&lt;/td&gt;
      &lt;td&gt;0.000&lt;/td&gt;
      &lt;td&gt;-100.000&lt;/td&gt;
      &lt;td&gt;0.060&lt;/td&gt;
      &lt;td&gt;sane&lt;/td&gt;
      &lt;td&gt;1.000&lt;/td&gt;
      &lt;td&gt;1.00E-09&lt;/td&gt;
      &lt;td&gt;0.150&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We can use the &lt;code class=&quot;language-python&quot;&gt;csv.reader&lt;/code&gt; function and skip the first line to create individual case parameter lists, or, we can use the &lt;code class=&quot;language-python&quot;&gt;csv.DictReader&lt;/code&gt; function to construct individual case dictionaries:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;with open('casefile.csv',newline='') as casefile: &lt;br /&gt;    casereader = csv.DictReader(casefile) &lt;br /&gt;    i = 0 &lt;br /&gt;    caselist = {} &lt;br /&gt;    for row in casereader:    &lt;br /&gt;        caselist[i] = row &lt;br /&gt;        print(row['case_name'], row['fluid'], row['mu']) # check that code works as expected &lt;br /&gt;        i += 1 &lt;br /&gt;&amp;gt;&amp;gt;&amp;gt; base water 0.001 &lt;br /&gt;&amp;gt;&amp;gt;&amp;gt; long water 0.001 &lt;br /&gt;&amp;gt;&amp;gt;&amp;gt; press water 0.001 &lt;br /&gt;&amp;gt;&amp;gt;&amp;gt; powder water 0.001 &lt;br /&gt;&amp;gt;&amp;gt;&amp;gt; oil oil 0.060 &lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;DictReader uses the first row of the CSV file as the keys and the subsequent row values are the dictionary entries. The only problem is that all entries are read as strings, which must convert the number variables to floats in the &amp;lt;pre&amp;gt;&lt;code class=&quot;language-python&quot;&gt;case_param&lt;/code&gt; &amp;lt;/pre&amp;gt; instantiation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class case_param(): &lt;br /&gt;    def __init__(self,param): &lt;br /&gt;        self.name = param['case_name'] # now the name is given inside the case, not as the case's actual name &lt;br /&gt;        self.dim = 1 # dimensions &lt;br /&gt;        self.x0 = 0.0 # inlet position &lt;br /&gt;        self.xL = self.x0 + float(param['length']) # outlet &lt;br /&gt;        fluid_name = param['fluid'] &lt;br /&gt;        mu = float(param['mu']) &lt;br /&gt;        u0 = 0.0 &lt;br /&gt;        p0 = float(param['p0']) # inlet pressure &lt;br /&gt;        pL = float(param['pL']) # outlet &lt;br /&gt;        self.fl = {'Name': fluid_name, 'mu': mu, 'u0': u0, 'p0': p0, 'pL': pL} &lt;br /&gt;        pm_name = param['porous_medium']  &lt;br /&gt;        K = float(param['K']) &lt;br /&gt;        eps = float(param['eps']) &lt;br /&gt;        self.pm = {'Name': pm_name, 'K':K, 'eps':eps} &lt;br /&gt;         self.fl['u0'] = -K/mu*(pL-p0)/(self.xL-self.x0) &lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;We can initialize the original base case and the oil case and compare the velocities:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt; base = case_param(caselist[0]) &lt;br /&gt; oil = case_param(caselist[4]) &lt;br /&gt; print(base.fl['u0'] &lt;br /&gt; &amp;gt;&amp;gt;&amp;gt; 9.999999999999999e-05 &lt;br /&gt; print(oil.fl['u0'] &lt;br /&gt; &amp;gt;&amp;gt;&amp;gt; 1.6666666666666667e-06 &lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;We can see that the viscous oil slows down the flow, as expected. We haven’t changed the Darcy's Law calculation so we know, at least, that the code is reading the CSV file correctly and initializing the case properly.&lt;/p&gt;

&lt;p&gt;The next step is to see what is going on between the inlet and outlet, specifically with the pressure.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Basic Python with Darcy's Law - Introduction</title>
   <link href="tim-munuhe.github.io/2021/04/18/darcys-law"/>
   <updated>2021-04-18T00:00:00-04:00</updated>
   <id>tim-munuhe.github.io/2021/04/18/Darcys-Law</id>
   <content type="html">&lt;p&gt;Darcy's law is an equation used to calculate fluid flow through a porous medium under a pressure gradient. It’s also a useful test problem to explore scientific computing with Python from a basic to intermediate level.&lt;/p&gt;

&lt;p&gt;Darcy's Law can be written as:&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;https://latex.codecogs.com/svg.image?\vec{u}&amp;space;=&amp;space;-\frac{K}{\mu}\nabla&amp;space;P&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;where &lt;img src=&quot;https://latex.codecogs.com/svg.image?\vec{u}&quot; alt=&quot;vel&quot; /&gt; is the superficial flow velocity, &lt;img src=&quot;https://latex.codecogs.com/svg.image?K&quot; alt=&quot;perm&quot; /&gt; is the hydraulic permeability of the porous medium, &lt;img src=&quot;https://latex.codecogs.com/svg.image?\mu&quot; alt=&quot;visc&quot; /&gt; is the viscosity of the liquid, and &lt;img src=&quot;https://latex.codecogs.com/svg.image?P&quot; alt=&quot;pres&quot; /&gt; is the pressure distribution. All three variables can vary over space. If the problem considered is 2D or 3D, then Darcy's Law becomes a partial differential equation (PDE).&lt;/p&gt;

&lt;p&gt;PDEs represent a myriad of phenomena mathematically, including heat transfer, electro-magnetism and the price of European options. You can find better discussions elsewhere but some prototypical equations to learn about are Laplace’s equation, Poisson’s equation, the Heat equation, and the Wave equation.&lt;/p&gt;

&lt;h3&gt;Problem Setup&lt;/h3&gt;

&lt;p&gt;Let's say we have a pipe filled with sand. A fluid can flow in the spaces between the individual grains of sand, termed the pores. Depending on how big or small or well-packed the sand grains are, it's easier or harder for the fluid to flow through the pipe. This is represented by &lt;img src=&quot;https://latex.codecogs.com/svg.image?K&quot; alt=&quot;perm&quot; /&gt;. The fluid's viscosity also affects how easily it can flow through the pores (maple syrup? or water? or air?).&lt;/p&gt;

&lt;p&gt;Basically, the porous medium and fluid flow properties are constant. Let's also assume that the pipe is long enough relative to its diameter that we can assume that pressure only varies significantly along its axis. Then, we can treat this as a 1D problem:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;https://latex.codecogs.com/svg.image?u&amp;space;=&amp;space;-\dfrac{K}{\mu}\dfrac{dP}{dx}&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;So now we have an ordinary differential equation, or ODE. To complete the description of the problem we need 2 boundary conditions. Let's give two boundary conditions:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;https://latex.codecogs.com/svg.image?P(x=0)&amp;space;=&amp;space;P_0&quot; /&gt;
&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;https://latex.codecogs.com/svg.image?P(x=L)&amp;space;=&amp;space;P_L&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Let's give some properties so we can move on:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Property&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Value&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://latex.codecogs.com/svg.image?K&quot; alt=&quot;perm&quot; /&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://latex.codecogs.com/svg.image?10^{-9}\;\frac{m^2}{s}&quot; alt=&quot;Kval&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://latex.codecogs.com/svg.image?\mu&quot; alt=&quot;visc&quot; /&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://latex.codecogs.com/svg.image?0.001\;Pa\cdot&amp;space;s&quot; alt=&quot;Kval&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://latex.codecogs.com/svg.image?P_0&quot; alt=&quot;perm&quot; /&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://latex.codecogs.com/svg.image?0\;Pa&quot; alt=&quot;Kval&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://latex.codecogs.com/svg.image?P_L&quot; alt=&quot;perm&quot; /&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://latex.codecogs.com/svg.image?-100\;Pa&quot; alt=&quot;Kval&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://latex.codecogs.com/svg.image?L&quot; alt=&quot;perm&quot; /&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://latex.codecogs.com/svg.image?1\;m&quot; alt=&quot;Kval&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3&gt;Enough Physics. Let's Code!&lt;/h3&gt;

&lt;p&gt;With our current assumptions, the superficial velocity at every point within the pipe is:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;https://latex.codecogs.com/svg.image?u=-\dfrac{K}{\mu}\dfrac{P_L-P_0}{L}&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Then we can solve it quite easily with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt; K = 1.0E-9 # permeability &lt;br /&gt; mu = 0.001 # viscosity &lt;br /&gt; P_0 = 0.0 # inlet &lt;br /&gt; P_L = -100.0 #outlet &lt;br /&gt; L = 1.0 # pipe length &lt;br /&gt; u = -K/mu*(P_L-P_0)/L &lt;br /&gt; print(u) &lt;br /&gt; &amp;gt;&amp;gt;&amp;gt; 9.999999999999999e-05  &lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;Simple, but now I can change the variables and get the velocity immediately. I can even add a bit of extra code to output results and create a sort of solution space examining the effects of different variables. However, the assumptions made to get here are pretty restrictive. What if we want to check the pressure along the pipe? What if the sand is not homogeneous? What if the viscosity of the fluid changes because of temperature? We need a more robust solution.&lt;/p&gt;

&lt;h3&gt;Some basic object-oriented programming&lt;/h3&gt;
&lt;p&gt;Admittedly, I'm still learning object-oriented programming so all I can do is write how I understand my code within the paradigm. That being said, the code will work, so take solace in that.
I want a more robust code that can take user input and tell the rest of the code how to run. So, I'm going to create a case object. I create a case class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class case_param(): &lt;br /&gt;    def __init__(self): &lt;br /&gt;        self.dim = 1 # dimensions &lt;br /&gt;        self.x0 = 0.0 # inlet position &lt;br /&gt;        self.xL = 1.0 # outlet &lt;br /&gt;        fluid_name = 'Water' &lt;br /&gt;        mu = 0.001 &lt;br /&gt;        u0 = 0.0 &lt;br /&gt;        p0 = 0.0 # inlet pressure &lt;br /&gt;        pL = -100.0 # outlet &lt;br /&gt;        self.fl = {'Name': fluid_name, 'mu': mu, 'u0': u0, 'p0': p0, 'pL': pL} &lt;br /&gt;        pm_name = 'Sand' &lt;br /&gt;        K = 1.0E-9 &lt;br /&gt;        eps = 0.15 &lt;br /&gt;        self.pm = {'Name': pm_name, 'K':K, 'eps':eps} &lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;This class, in short, defines case objects through common variables: number of dimensions, inlet and outlet position, and the fluid and porous medium used and their properties. The fluid and porous medium are both represented thorugh dictionaries which other objects or methods can refer to. Let's use it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;base = case_param() &lt;br /&gt;base.u0 = -base.pm['K']/base.fl['mu']*(base.fl['pL']-base.fl['p0'])/(base.xL-base.x0) &lt;br /&gt;print(base.u0) &lt;br /&gt;&amp;gt;&amp;gt;&amp;gt; 9.999999999999999e-05 &lt;/code&gt; &lt;/pre&gt;

&lt;p&gt;So, we've got the same result as the previous, simpler code. We’ve also created a case object that the other to-be-created code can use. For now, let me compress the code by initializing the superficial velocity in the instantiation (__init__ method):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class case_param(): &lt;br /&gt;    def __init__(self): &lt;br /&gt;        self.dim = 1 # dimensions &lt;br /&gt;        self.x0 = 0.0 # inlet position &lt;br /&gt;        self.xL = 1.0 # outlet &lt;br /&gt;        fluid_name = 'Water' &lt;br /&gt;        mu = 0.001 &lt;br /&gt;        u0 = 0.0 &lt;br /&gt;        p0 = 0.0 # inlet pressure &lt;br /&gt;        pL = -100.0 # outlet &lt;br /&gt;        self.fl = {'Name': fluid_name, 'mu': mu, 'u0': u0, 'p0': p0, 'pL': pL} &lt;br /&gt;        pm_name = 'Sand' &lt;br /&gt;        K = 1.0E-9 &lt;br /&gt;        eps = 0.15 &lt;br /&gt;        self.pm = {'Name': pm_name, 'K':K, 'eps':eps} &lt;br /&gt;        self.fl['u0'] = -K/mu*(pL-p0)/(self.xL-self.x0) &lt;br /&gt;&lt;br /&gt;base = case_param() &lt;br /&gt;print(base.fl['u0']) &lt;br /&gt;&amp;gt;&amp;gt;&amp;gt; 9.999999999999999e-05 &lt;/code&gt; &lt;/pre&gt;
&lt;p&gt;Later, I'll be able to pass this to a mesh object and Darcy’s law method to create a solution that I can plot and output to CSV.&lt;/p&gt;
</content>
 </entry>
 

</feed>
